/**
 * @file rollo_ekf.cpp
 * @author Rabbia Asghar
 * @date 20/2/16
 * @brief EKF implementation for localisation of the robot
 *
 * Takes control input from rollo_communication node and measurement from rollo_preprocessor
 * publishes estimated state after the processing
 * @see https://github.com/em-er-es/rollo/
 * 
 * Filter the raw data from optitrack motion capture system and 
 * publish it for modeling of odomety and the measurement in Kalman Filter
 * 
 * sample command: rosrun rollo rollo_ekf _rate:=1 _samplesize:=5 _sampling:=0
 *  _rate is the sampling frquency of the node, default value is 1
 *  _samplesize is the no. of elements that are averaged/subsampled, default value is 10
 *  _sampling selects if the raw data should be subsampled after a certain delay or averaged over a certain period
 *  _sampling 0 represents subsampling and any number other than 0 represents averaging, default is set to subsampling
 */


#include "ros/ros.h"
#include "std_msgs/String.h"
#include "std_msgs/Header.h"
#include "geometry_msgs/Pose.h"
#include "geometry_msgs/Pose2D.h"
#include "tf/tf.h"
#include "rollo/Pose2DStamped.h"
#include <sstream>
#include <iostream>
#include <eigen3/Eigen/Dense>


#define LeftWheelRadius 0.02
#define RightWheelRadius 0.02

/**
 * @brief Global variables updated in the SubscriberCallback function and later used in main to process and then publish.
 * 
 */
 // Naming conventions:
// Global and important variables: CapitalLettersFullName
// Local, temporary and irrelevant variables: shortlowercase
// Functions priority: CapitalLettersFunctions
// Functions conventional: firstLowerLetterFunction
// Functions and variables special: _FullDescription

double x, y, theta;
double x_mm, y_mm, theta_deg;


/**
 * @brief SubscriberCallback function
 *
 * This is a gloabal function that subscribes to the topic 'ground_pose' of the Optitrack node.
 * It reads position and orientation from Optitrack node.
 * @param msg message generated by Optitrack node contains position in x and y in metres and orienatation in radians.
 * @return NULL
 */

void subscriberCallback(const geometry_msgs::Pose2D::ConstPtr& msg) {
	x = msg->x; //raw x is in metres
	x_mm = 1000 * x;
	y = msg->y; //raw y is in metres
	y_mm = 1000 * y;
	theta = msg->theta; //raw theta is in radians
	theta_deg = theta / 3.14159265359 * 180 + 180; //converted in degrees and in the range 0 to 360 degress
	// ROS_INFO("[Rollo][Sub][X, Y, Theta]: %f, %f, %f", msg->x, msg->y, msg->theta);
	// ROS_INFO("[Rollo][Sub][X, Y, Theta]: %f, %f, %f, %f", msg->x, msg->y, msg->theta, theta_deg);
	ROS_INFO("[Rollo][Sub][X, Y, Theta]: %f, %f, %f", x_mm, y_mm, theta_deg);
}


//! nonlinear state equations, f(x_k-1,u_k-1)
Eigen::Vector3d  FSTATE(Eigen::Vector3d x_pp, Eigen::Vector2d u) {
	Eigen::Vector3d x_cp(x_pp(0) + u(0)*cos(x_pp(2) - (u(1)/2)), x_pp(1) + u(0)*sin(x_pp(2) - (u(1)/2)), x_pp(2) - u(1)); 
return x_cp;
}

//! measurement equation, h(x_k)
Eigen::Vector3d  HMEAS(Eigen::Vector3d x_pp) {
	Eigen::Vector3d h_x (x_pp(0), x_pp(1), x_pp(2)); 
return h_x;
}

//! Jacobian matrix with the partial derivatives of f(x_k-1,u_k-1) w.r.t x
Eigen::Matrix3d JacobianFSTATE(Eigen::Vector3d x_cp, Eigen::Vector2d u) {
	Eigen::Matrix3d Jf_xu = Eigen::Matrix3d::Identity(); 
	Jf_xu(0,2) = - u(0)*sin(x_cp(2) - (u(1)/2));
	Jf_xu(1, 2) = u(0) * cos(x_cp(2) - (u(1) / 2));
return Jf_xu;
}

                 

/**
 * @brief Main function
 *
 * Initializes variables, Nodehandle, subsrcribes to Optitack Ground_pose and publishes postition and orientation after filtering.
 * It also accepts 3 arguments from command line: rate,  samplesize, sampling.
 * The position and orientation are published to topic /Rollo/pose in configuration geometry_msgs::Pose2D
 * @return 0
 */
int main(int argc, char **argv)
{

//! Initialize node 
ros::init(argc, argv, "rollo_ekf"); // name of the converter node
ros::start(); // Necessary to be called

//! Initialize nodehandle for subscriber and publisher
ros::NodeHandle RolloEKF;

//! Subscriber
ros::Subscriber PoseSub = RolloEKF.subscribe("/Optitrack_Rollo/ground_pose", 1024, subscriberCallback);

//! Initialie publisher and define topic and message queue size for the publisher
ros::Publisher RolloPub = RolloEKF.advertise<rollo::Pose2DStamped>("/Rollo/pose", 1024);
//ros::Publisher RolloPub = RolloEKF.advertise<geometry_msgs::Pose2D>("/Rollo/pose", 1024);

//! Initialize node arguments using command line
int rate_frequency;

// Sample command: rosrun rollo rollo_node _rate:=1 _samplesize:=5 _sampling:='0'
//! Initialize node parameters from launch file or command line.
//! Use a private node handle so that multiple instances of the node can be run simultaneously
//! while using different parameters.
ros::NodeHandle private_node_handle_("~");
private_node_handle_.param("rate", rate_frequency, int(1));

//! publishing rate in units of Hz
ros::Rate frequency(rate_frequency); 

int loopcondition = 1;

//! Initializing variables involved in computation of EKF
//! Define number of states
int nstates = 3;      //number of states is 3, position in x, in y and orientation

//! Initialize noise covariances and matrices

double q = 0.1;    //std of process noise  
double r = 0.1;    //std of measurement noise

Eigen::Matrix3d Q = Eigen::Matrix3d::Identity(); //q^2*eye(n); // process noise covariance 
Q(0,0) = q*q;
Q(1,1) = q*q;
Q(2,2) = q*q;

Eigen::Matrix3d R = Eigen::Matrix3d::Identity(); //r^2*eye(n); //measurement noise covariance
R(0,0) = r*r;
R(1,1) = r*r;
R(2,2) = r*r;

  std::cout << "Q:\n" << Q << "\nR:\n" << R << "\n" << std::endl;

//! nitialize vector u, control input, and variables involved in its computation

Eigen::Vector2d u(0, 0);

double SL = 0;
double SR = 0;
double dt = 1; //determine time from timestamp
double nL = 1;
double nR = 1;
double deltaTheta;
double deltaS;

//! Determine u, control input from nL and nR, subscription from odometry/communication node
 SL = dt * (nL / 60) * 2 * PI * LeftWheelRadius; // Linear distance traveled by left wheel in meters
 SR = dt * (nR / 60) * 2 * PI * RightWheelRadius; // Linear distance traveled by right wheel in meters
 deltaTheta = (SL - SR) / 2; //%u(2)
 deltaS = (SL + SR) / 2; //% u(1)
 u << deltaS, deltaTheta;

  std::cout << "SL: " << SL << " SR: " << SR << "\n" << std::endl;
  std::cout << "deltaTheta " << deltaTheta << " deltaS " << deltaS << "\n" << std::endl;
  std::cout << "u:\n" << u << "\n" << std::endl;


//! Initializing state estimate vector "a priori" and meaurement vector
Eigen::Vector3d x_pp(0, 0, 0);
Eigen::Vector3d z(0, 0, 0);

//! Initializing functions and jacobians for the system

/*
//! nonlinear state equations, f(x_k-1,u_k-1)
Eigen::Vector3d f_xu(x_pp(0) + u(0)*cos(x_pp(2) - (u(1)/2)), x_pp(1) + u(0)*sin(x_pp(2) - (u(1)/2)), x_pp(2) - u(1)); 

//! measurement equation, h(x_k)
Eigen::Vector3d h_x (x_pp(0), x_pp(1), x_pp(2));                  

//! Jacobian matrix with the partial derivatives of f(x_k-1,u_k-1) w.r.t x
Eigen::Matrix3d Jf_xu = Eigen::Matrix3d::Identity(); 
Jf_xu(0,2) = - u(0)*sin(x_pp(2) - (u(1)/2));
Jf_xu(1,2) = u(0)*cos(x_pp(2) - (u(1)/2));
*/
//! Jacobian matrix with the partial derivatives of h(x_k) w.r.t x, identity for our system
Eigen::Matrix3d Jh = Eigen::Matrix3d::Identity(); 


//! Initializing E_pp: "a priori" estimated state covariance, E_k-1|k-1 (p refers to k-1) 
static Eigen::Matrix3d E_pp = Eigen::Matrix3d::Identity(); // initial state covraiance

//! Initializing variables involved in the prediction update of EKF
Eigen::Vector3d x_cp; //%state prediction, x_k|k-1
Eigen::Matrix3d Jf;
Eigen::Matrix3d E_cp; //%E_k|k-1
  
//! Initializing variables involved in the innovation update of EKF
Eigen::Vector3d z_estimate;
Eigen::Matrix3d P12;
Eigen::Matrix3d S_inv;
Eigen::Matrix3d H;

//! Initializing state estimate vector and state covariance matrix a posteriori
Eigen::Vector3d x_cc;
Eigen::Matrix3d E_cc;


// testing with dummy values
x_pp <<     1.4636,
			0.2857,
			-2.9372;

u <<   -0.00006935,
        0;

z <<    1.4264,
		0.3084,
		-3.0485;
		
/*E_pp <<	0.0062,    0.0000,    0.0000,
		-0.0000,    0.0062,    0.0000,
		-0.0000,    0.0000,    0.0062;
*/

//! loop
do {

//! PREDICTION UPDATE
//! nonlinear update and linearization at current state
x_cp = FSTATE(x_pp, u); //f_xu; //%state prediction, x_k|k-1
Jf = JacobianFSTATE(x_cp, u);


  std::cout << "x_cp:\n" << x_cp << "\nE_pp:\n" << E_pp << "\n" << std::endl;
  std::cout << "Jf_xu:\n" << Jf << "\nJh:\n" << Jh << "\n" << std::endl;

//! partial covariance update
E_cp = Jf*E_pp*Jf.transpose() + Q;  // %E_k|k-1              

//! INNOVATION UPDATE
//! nonlinear measurement and linearization   
z_estimate = HMEAS(x_pp);

P12 = E_cp*Jh.transpose(); //%cross covariance
S_inv = (Jh*P12 + R).inverse();
H = P12*S_inv; //     %Kalman filter gain, H_k

x_cc = x_cp + H*(z-z_estimate); //    %state estimate, x_k|k;
E_cc = E_cp - H*P12.transpose();  //             %state covariance matrix, E_k|k

//! update E_cp for next loop
E_pp = E_cc; 


std::cout << "x_cc:\n" << x_cc << "\nE_cc:\n" << E_cc << "\n" << std::endl;

//! prepare data for publishing
geometry_msgs::Pose2D PubRolloPositionPose2d;
PubRolloPositionPose2d.x = 1;
PubRolloPositionPose2d.y = 2;
PubRolloPositionPose2d.theta = 3;

rollo::Pose2DStamped test;
test.pose = PubRolloPositionPose2d;
//! publish
RolloPub.publish(test);




loopcondition = 0;
ros::spinOnce();

// ROS_INFO("[Rollo][Debug][Counter]: %d", loopcounter);

if (! ros::ok()) loopcondition = 0;

//! if we are averaging: sleep for time defined by rate before reading states from the subscriber callback()
frequency.sleep();

} while (loopcondition);
//!  end while loop


return 0;
}

/*
function [x_cc,E_cc]= my_ekf_node(x_pp,u,z)
% Original code: By Yi Cao at Cranfield University, 02/01/2008
% Modified by: Rabbia Asgahr specific to Odometry, 15/02/2016
% Modified further: specific to ROS node, 19/2/2016
% EKF   Extended Kalman Filter for localization of a robot (nonlinear
% dynamic systems)
% [x_cc,E_cc]= my_ekf_node(x_pp,u,z) returns state estimate, x and state covariance, P 
% for nonlinear dynamic system:
%           x_k = f(x_k-1, u_k-1) + w_k
%           z_k   = h(x_k) + v_k
% where w ~ N(0,Q) meaning w is gaussian noise with covariance Q
%       v ~ N(0,R) meaning v is gaussian noise with covariance R
% Inputs:   x_pp: "a priori" state estimate, x_k-1|k-1 (p refers to k-1)  
%           u: control input, u_k-1 (only for simulation here, originally
%           node will receive nL and nR
%           z: current measurement
% Output:   x_cc: "a posteriori" state estimate, x_k|k (c refers to k) 
%           E_cc: "a posteriori" state covariance, E_k|k (c refers to k) 
%

%% preinitialized variables and functions in the system

n=3;      %number of states

%however Q will need to be modeled in actual system
q=0.1;    %std of process noise  
r=0.1;    %std of measurement noise
Q=q^2*eye(n); % process noise covariance 
R=r^2*eye(n); % measurement noise covariance

%% calculations for u in the node
% SL = dt * (nL / 60) * 2 * pi * rL; % Linear distance traveled by left wheel in meters
% SR = dt * (nR / 60) * 2 * pi * rR; % Linear distance traveled by right wheel in meters
% del_theta = (SL - SR) / 2; %u(2)
% del_S = (SL + SR) / 2; % u(1)
% u = [del_S,  del_theta];

%% functions and jacobians
f_xu = [x_pp(1) + u(1)*cos(x_pp(3) - (u(2)/2)); x_pp(2) + u(1)*sin(x_pp(3) - (u(2)/2)); x_pp(3) - u(2)];  % nonlinear state equations, f(x_k-1,u_k-1)
h_x = [x_pp(1); x_pp(2); x_pp(3)];                  % measurement equation, h(x_k)

Jf_xu = [1, 0, - u(1)*sin(x_pp(3) - (u(2)/2)); 0, 1, u(1)*cos(x_pp(3) - (u(2)/2)); 0, 0, 1]; %Jacobian matrix with the partial derivatives of f(x_k-1,u_k-1) w.r.t x
Jh = eye(n); %Jacobian matrix with the partial derivatives of h(x_k) w.r.t x, identity for our system

%E_pp: "a priori" estimated state covariance, E_k-1|k-1 (p refers to k-1) 
persistent E_pp;
if isempty(E_pp) 
    E_pp = eye(n);            % initial state covraiance
end


%% PREDICTION UPDATE
%nonlinear update and linearization at current state
x_cp = f_xu; %state prediction, x_k|k-1
Jf = Jf_xu;

%partial covariance update
E_cp = Jf*E_pp*Jf' + Q;  %E_k|k-1              

%% INNOVATION UPDATE
%nonlinear measurement and linearization   
z_estimate = h_x;

P12=E_cp*Jh'; %cross covariance
S_inv = inv(Jh*P12+R);
%M_inv = matrix3by3_inverse(H*P12+R)
H = P12*S_inv;      %Kalman filter gain, H_k

x_cc = x_cp + H*(z-z_estimate);     %state estimate, x_k|k;
E_cc = E_cp - H*P12';               %state covariance matrix, E_k|k

% update E_cp for next loop
E_pp = E_cc; */
