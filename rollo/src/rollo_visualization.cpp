/**
 * @file rollo_visualization.cpp
 * @author Rabbia Asghar
 * @author Ernest Skrzypczyk
 * 
 * @date 25/2/16
 * 
 * @brief Visualize motion capture data and EKF estimates
 * 
 * Command prototype: <b>rosrun rollo rollo_visualization _rate:=25</b>
 * \param rate Running frequency of the node <!25 [Hz]>
 * \param savepath Save path of generated images <!.>
 * \param type Type of saved images <!png>
 * \param format Format of saved images (dim_x x dim_y) <!512>
 * \param duration Duration of visualization <!0>
 *
 * Subscribe to provided data and estimates and plot results in pseudo realtime
 * 
 * @see https://github.com/em-er-es/rollo/
 * 
 */


/* TODO
 * FIX DOXYGEN documentation format
 * Subscribe to preprocessor topic
 * Subscribe to EKF topic
 * TODO later
 * Implement saving generated images to a path
 * Implement a duration parameter
// */


#include "ros/ros.h"
#include <stdio.h>
#include <unistd.h>
#include <sstream>
#include <iostream>
#include "rollo.hpp"
#include "rollo/Pose2DStamped.h"
// #include "rollo/WheelSpeed.h"
#include "rollo/EKF.h"


/**
 * @brief Global variables.
 * 
 */

//! Node name using console codes
char NodeName[20] = C5 VS CR; // The size is necessary for the GNU/Linux console codes //COLOR
// char NodeName[20] = CT; // The size is necessary for the GNU/Linux console codes //COLOR

// Topics
//! Topic for commands generated expressed in linear and angular velocity
char TopicCmdVel[64] = TOPIC_CTRL_CMD_VEL;

//! Limit velocity forward
double LimitVelocityF = 1;
//! Limit velocity reverse
double LimitVelocityR = -1;

//! Left key set velocity step
double LKeysSteps = 0.1;
//! Right key set linear velocity step
double RKeysLinearV = 0.4;
//! Right key set angular velocity step
double RKeysAngularV = 1;



/**
 * @brief Subscriber callback
 *
 * Subscribe to motion capture data from @ref mocap_optitrack and estimation data from extended Kalman filter node.
 * Call Python visualization script.
 *
 * \param msg Message generated by @ref mocap_optitrack node in format:
 * - Position x [m]
 * - Position y [m]
 * - Orientation [rad]
 *
 * @see https://github.com/ros-drivers/mocap_optitrack
 *
 * @return NULL
 */

void subscriberCallback(const geometry_msgs::Pose2D::ConstPtr& msg) {
	//! Acquisition:
	//! - Raw x coordinate [m]
	x = msg->x;
	x_mm = 1000 * x;
	//! - Raw y coordinate [m]
	y = msg->y;
	y_mm = 1000 * y;
	//! - Raw theta [rad]
	theta = msg->theta;
	//! Conversion into degrees in the range 0 to 360 degress
	theta_deg = theta / PI * 180 + 180;
	//! Print message with acquired data
	ROS_INFO("[Rollo][%s][Sub][X [mm], Y [mm], Theta [deg]]: %f, %f, %f", NodeName, x_mm, y_mm, theta_deg);
}


/**
 * @brief Subscriber callback
 *
 * Subscribe to motion capture data from @ref mocap_optitrack and estimation data from extended Kalman filter node.
 * Call Python visualization script.
 *
 * \param msg Message generated by @ref mocap_optitrack node in format:
 * - Position x [m]
 * - Position y [m]
 * - Orientation [rad]
 *
 * @see https://github.com/ros-drivers/mocap_optitrack
 *
 * @return NULL
 */

void subscriberCallback(const geometry_msgs::Pose2D::ConstPtr& msg) {
	//! Acquisition:
	//! - Raw x coordinate [m]
	x = msg->x;
	x_mm = 1000 * x;
	//! - Raw y coordinate [m]
	y = msg->y;
	y_mm = 1000 * y;
	//! - Raw theta [rad]
	theta = msg->theta;
	//! Conversion into degrees in the range 0 to 360 degress
	theta_deg = theta / PI * 180 + 180;
	//! Print message with acquired data
	ROS_INFO("[Rollo][%s][Sub][X [mm], Y [mm], Theta [deg]]: %f, %f, %f", NodeName, x_mm, y_mm, theta_deg);
}


/**
 * @brief Node main
 *
 * Initialize variables and nodehandle, read and translate input information into command messages.\n
 * 
 * \param rate Running frequency of the node <!10 [Hz]>
 * 
 * Publish to command velocity topic as specified in configuration header file according to format @p geometry_msgs::Twist
 * 
 * @return 0
 */
//* Publish to command velocity topic as specified in configuration header @file rollo.hpp according to format @p geometry_msgs::Twist

int main(int argc, char **argv)
{
//! # Algorithm structure
//! ## Initialization
ros::init(argc, argv, "rollo_control");
ros::start();

//! - Initialize nodehandle for publisher
ros::NodeHandle RolloControlNode;

//! - Publisher initialization with topic, message format and queue size definition
ros::Publisher RolloTwist = RolloControlNode.advertise<geometry_msgs::Twist>(TopicCmdVel, 1024);

//! - Node arguments using command line
int rate_frequency;

//! - Initialize node parameters from launch file or command line.
//! Use a private node handle so that multiple instances of the node can be run simultaneously
//! while using different parameters.
ros::NodeHandle private_node_handle_("~");
private_node_handle_.param("rate", rate_frequency, int(100));

//! - Publishing rate [Hz]
ros::Rate frequency(rate_frequency); 

//! - Publisher variables for conventional messages
geometry_msgs::Twist PubRolloCmd;

//! - Initialize variables for computing linear and angular velocity of the robot
double Speed = 0;
double Turn = 0;

//! - Initialize character holder
char c = 0;

//! ## Main loop
while (ros::ok()) {

	//! - Check if a key is pressed
	if (kbhit()) {
		//! - Read character
		c  =  getchar();

		//! - Decode key pressed
		decodeKey(c, Speed, Turn);
	}

	//! - Prepare message to publish linear and angular velocities
	PubRolloCmd.linear.x = Speed;
	PubRolloCmd.angular.z = Turn;

	//! - Print message with velocities
	ROS_INFO("[Rollo][%s][Pub] Linear speed [%f] Angular speed [%f]", NodeName, PubRolloCmd.linear.x, PubRolloCmd.angular.z);
	//! - Publish message in Twist format
	RolloTwist.publish(PubRolloCmd);

	//! - ROS spinOnce
	ros::spinOnce();

	//! - Sleep to connform node frequency rate
	frequency.sleep();

}
//! ## Main loop end

return 0;
}
