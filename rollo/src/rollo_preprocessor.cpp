/**
 * @file rollo_node.cpp
 * @author Rabbia Asghar, Ernest Skrzypczyk
 * @date 16/2/16
 * @brief Preprocessor for Rollo measurement using Mocap OptiTrack motion capture data
 *
 * Filter the raw data from optitrack motion capture system and 
 * publish it along with time stamp for modeling of odometry and the measurement in Kalman Filter
 * 
 * Command: rosrun rollo rollo_node _rate:=1 _samplesize:=5 _sampling:=0
 *  _rate: Sampling frquency of the node, default value is 1
 *  _samplesize: Number of elements that are averaged/subsampled, default value is 10
 *  _sampling: Selects if the raw data should be subsampled after a certain delay or averaged over a certain period
 *  _sampling 0 sets subsampling and any number other than 0 sets averaging, default is set to subsampling
 */


#include "ros/ros.h"
#include "std_msgs/String.h"
#include "geometry_msgs/Pose.h"
#include "geometry_msgs/Pose2D.h"
#include "rollo/Pose2DStamped.h"
#include "tf/tf.h"
#include <sstream>
#include <iostream>
#include "rollo_nodes.h"


/**
 * @brief Global variables updated in the SubscriberCallback function, processed and published.
 * 
 */

char NodeName[20] = C1 PP CR; // The size is necessary for the GNU/Linux console codes //~COLOR
// char NodeName[20] = PP; // The size is necessary for the GNU/Linux console codes //~COLOR
double x, y, theta;
double x_mm, y_mm, theta_deg;


/**
 * @brief SubscriberCallback function
 *
 * This is a global function that subscribes to the topic 'ground_pose' of the Optitrack node.
 * It reads position and orientation from Optitrack node.
 * @param msg message generated by Optitrack node contains position in x and y in metres and orienatation in radians.
 * @return NULL
 */

void subscriberCallback(const geometry_msgs::Pose2D::ConstPtr& msg) {
	x = msg->x; // Raw x coordinate [m]
	x_mm = 1000 * x;
	y = msg->y; // Raw y coordinate [m]
	y_mm = 1000 * y;
	theta = msg->theta; // Raw theta [rad]
	theta_deg = theta / PI * 180 + 180; // Conversion into degrees in the range 0 to 360 degress
	ROS_INFO("[Rollo][%s][Sub][X(mm), Y(mm), Theta(deg)]: %f, %f, %f", NodeName, x_mm, y_mm, theta_deg);
}


/**
 * @brief Main function
 *
 * Initializes variables, nodehandle, subscribes to Optitack Ground_pose and publishes position and orientation after processing.
 * It accepts 3 arguments from command line: rate, samplesize, sampling.
 * The position and orientation are published along with timestamp to topic /Rollo/preprocessor/pose2dstamped in format custom defined message, rollo::Pose2DStamped .
 * @return 0
 */
int main(int argc, char **argv)
{

//! Initialization 
ros::init(argc, argv, "rollo_preprocessor"); // Name of the preprocessor node
ros::start(); // ROS internal function, neccessary to be called

//! Nodehandle for subscriber and publisher
ros::NodeHandle RolloPreprocessorNode;

//! Subscriber
ros::Subscriber PoseSub = RolloPreprocessorNode.subscribe("/Optitrack_Rollo/ground_pose", 1024, subscriberCallback);

//! Publisher initialization with topic, message format and queue size definition
ros::Publisher RolloPub = RolloPreprocessorNode.advertise<rollo::Pose2DStamped>("/Rollo/preprocessor/pose2dstamped", 1024);

//! Node arguments using command line
int rate_frequency;
int samplesize;
int sampling; // Sampling is either done using subsampling (0) or simple averaging (1) 

// Command: rosrun rollo rollo_preprocessor _rate:=1 _samplesize:=5 _sampling:=0
//! Initialize node parameters from launch file or command line.
//! Use a private node handle so that multiple instances of the node can be run simultaneously
//! while using different parameters.
ros::NodeHandle private_node_handle_("~");
private_node_handle_.param("rate", rate_frequency, int(1));
private_node_handle_.param("samplesize", samplesize, int(4));
private_node_handle_.param("sampling", sampling, int(0));

//! Publishing rate [Hz]
ros::Rate frequency(rate_frequency); 

//! Publisher variables for conventional messages
std_msgs::String Message;
std::stringstream StringStream;

std_msgs::String PubRolloPosition; // Declaration of message type

//! Publisher variables for processing
double sum_x = 0;
double sum_y = 0;
double sum_theta = 0;

double average_x = 0;
double average_y = 0;
double average_theta = 0;

//! Initialize variable to publish message
rollo::Pose2DStamped PubRolloPositionPose2dStamped;
PubRolloPositionPose2dStamped.header.frame_id = '1'; // Global frame


int loopcounter = 0;
int loopcondition = 1; // For while(1) loop


//! Loop
do {
	sum_x += x;
	sum_y += y;
	sum_theta += theta;


	if (loopcounter >= samplesize)
	{
		average_x = sum_x / samplesize;
		average_y = sum_y / samplesize;
		average_theta = sum_theta / samplesize;

		//StringStream << "[Rollo][" << NodeName << "][X, Y, Theta]: " << x_mm << ", " << y_mm << ", " << theta_deg << "\n";
		//StringStream << "[Rollo][" << NodeName << "][X, Y, Theta]: " << sum_x_mm << ", " << sum_y_mm << ", " << sum_theta_deg << "\n";
		//StringStream << "[Rollo][" << NodeName << "]["<<samplesize<<"][X, Y, Theta]: " << average_x_mm << ", " << average_y_mm << ", " << average_theta_deg << "\n";
		//StringStream << "[Rollo][" << NodeName << "][X, Y, Theta]: " << average_x_mm << ", " << average_y_mm << ", " << average_theta_deg << "\n";
		//PubRolloPosition.data = StringStream.str();

		//! Prepare data for publishing
		PubRolloPositionPose2dStamped.pose.x  = average_x;
		PubRolloPositionPose2dStamped.pose.y  = average_y;
		PubRolloPositionPose2dStamped.pose.theta  = average_theta;
		PubRolloPositionPose2dStamped.header.stamp = ros::Time::now();

		//! publish
		RolloPub.publish(PubRolloPositionPose2dStamped);

		//! Reset variables
		loopcounter = 0;
		sum_x  = 0;
		sum_y  = 0;
		sum_theta = 0;

		//! For subsampling sleep for time defined by rate and then read the states from the subscriber callback() without sleep() delay 
		if (sampling == 0) frequency.sleep();
	}


	// ROS_INFO("[Rollo][%s][Debug][Counter]: %d", NodeName, loopcounter); //DB
	ros::spinOnce();
	if (! ros::ok()) loopcondition = 0;

	//! For averaging sleep for time defined by rate before reading states from the subscriber callback()
	if (sampling != 0) frequency.sleep();
	loopcounter++;

} while (loopcondition);
//! End loop

// ros::shutdown();
return 0;
}
