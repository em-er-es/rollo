% % % Document class
\documentclass{report}
%\documentclass{article}
% "article" = page number on title page
% "report" = no page number on title page


% % % Naming conventions
% % Cross references
% Algorithms - \label{a:label} \ref{a:label}
% Equations - \label{e:label} \eref{e:label}
% Figures - \label{f:label} \fref{label}
% Sections - \label{s:label} \ref{s:label}
% Tables - \label{t:label} \ref{t:label}
% Subsections - \label{s:mainlabel--subsectionlabel} \ref{s:mainlabel--subsectionlabel}
% Subsubsections - \label{s:mainlabel--subsectionlabel--subsubsectionlabel} \ref{s:mainlabel--subsectionlabel--subsubsectionlabel}
% % Numbering
% Sections - n * 10; n = 1, 2, ... - gives the possibility to shift other sections in between
% Equations - 
% Figures - 

% % % User packages
% % Languages
\usepackage{amsmath,amsfonts,amsthm,amssymb}
\usepackage[T1]{fontenc}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[polish,german,english]{babel}
% % General
\usepackage[usenames,dvipsnames]{color}
%\usepackage{cleveref}
\usepackage{extramarks}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{gensymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{chngpage}
\usepackage{soul}
\usepackage[retainorgcmds]{IEEEtrantools}
\usepackage{ifthen}
\usepackage{lastpage}
\usepackage{listings}
\usepackage{cancel}
\usepackage{courier}
\usepackage{layout}
\usepackage{lscape}
\usepackage{media9}
\usepackage{multicol}
\usepackage{multimedia}
\usepackage{multirow}
\usepackage{pdflscape}
\usepackage{setspace}
\usepackage{tabularx}
\usepackage{varioref}
\usepackage{wrapfig}
\usepackage{xcolor}
\usepackage{xfrac}
\usepackage{xstring}


% % % Packages configuration
% % Tabular
\newcolumntype{Y}{>{\centering\arraybackslash}X}


% % % Command definitions
% % References
\newcommand{\aref}[1]{\autoref{#1}}
\newcommand{\bref}[1]{(\ref{#1})}
%\newcommand{\cref}[1]{(\afig\ref{#1})}
%\renewcommand{\eqref}[1]{(\ref{e:#1})}
\newcommand{\eref}[1]{(\ref{#1})}
\newcommand{\fref}[1]{\ref{f:#1}}
\newcommand{\sref}[1]{\ref{s:#1}}
\newcommand{\tref}[1]{\ref{t:#1}}
% % Symbols
\newcommand{\dlsh}{\reflectbox{\rotatebox[origin=c]{180}{$\Lsh$}}}
\newcommand{\drsh}{\reflectbox{\rotatebox[origin=c]{180}{$\Rsh$}}}
\newcommand\ccancel[2][black]{\renewcommand\CancelColor{\color{#1}}\cancel{#2}}
\newcommand\ccancelto[3][black]{\renewcommand\CancelColor{\color{#1}}\cancelto{#2}{#3}}
% % Font styles
\newcommand\dunderline[1]{\underline{\underline{\ #1\ }}}
\newcommand\sunderline[1]{\underline{\ #1\ }}
% % Mathematical symbols and structures
%\renewcommand{\vec}[1]{\overrightarrow{\mathbf{#1}}}
\renewcommand{\vec}[1]{\mathbf{\overline{#1}}}
% % Other
\StrLeft{\figurename}{1}[\afig]

% % Complex definitions
% Links
% Generic hyperlink -- \link[optional text]{link}
\newcommand*{\link}[2][]{
	\ifthenelse{\equal{#1}{}}
	{\href{#2}{#2}}
	{\href{#2}{#1}}}

% Http hyperlink -- \httplink[optional text]{link}
\newcommand*{\httplink}[2][]{
	\ifthenelse{\equal{#1}{}}
	{\href{http://#2}{#2}}
	{\href{http://#2}{#1}}}

% Email hyperlink -- \emaillink[optional text]{link}
\newcommand*{\emaillink}[2][]{
	\ifthenelse{\equal{#1}{}}
	{\href{mailto:#2}{#2}}
	{\href{mailto:#2}{#1}}}

% Graphics
% Inkscape path
%\IfFileExists{/dev/null}{
%	\newcommand{\Inkscape}{/usr/bin/inkscape }}{
%	\newcommand{\Inkscape}{"C:/Program Files (x86)/Inkscape/inkscape.exe" }
%}

% Include SVG-LaTeX within scalebox
%\includesvga[0.75]{Graphics/10-odometry--right-turn}
%\includesvga[scalebox]{input-files-w/o-ext}
\newcommand{\includesvgsb}[2][1]{
%	\IfFileExists{\Inkscape}{
%		\immediate\write18{\Inkscape -z -D --file="#2.svg" --export-pdf="#2.pdf" --export-dpi=72 --export-latex}}{}
	\scalebox{#1}{\input{#2.pdf_tex}}
}

% Include SVG-LaTeX as figure
%\includesvg[0.75]{a}{Automated includesvg pdf\label{f:f4b}}
%\includesvg[scale]{input-files-w/o-ext}{caption\label{f:id}}
\newcommand{\includesvg}[3][1]{
%	\IfFileExists{\Inkscape}{
%		\immediate\write18{/home/emeres/.bin/testbell}
%		\immediate\write18{\Inkscape -z -D --file="#2.svg" --export-pdf="#2.pdf" --export-dpi=96 --export-latex}}{}
	\begin{figure}[!ht]
%		\centering
		\begin{center}
			\def\svgwidth{#1\columnwidth}
			\input{#2.pdf_tex}
			\caption{#3}
		\end{center}
	\end{figure}
}

% Scaled figure
\newcommand{\scalefig}[3]{
	\begin{figure}[!ht]
%		\centering
		\begin{center}
			\includegraphics[width=#2\columnwidth]{#1}
			\caption{#3}
		\end{center}
	\end{figure}
}

% Scaled and trimmed figure
\newcommand{\scalefigcrop}[7]{
	\begin{figure}[!ht]
%		\centering
		\begin{center}
			\includegraphics[trim=#4 #5 #6 #7, clip, width=#2\columnwidth]{#1}
			\caption{#3}
		\end{center}
	\end{figure}
}

% Script listing
\newcommand{\script}[3]
{\lstinputlisting[caption=#2,label=#1]{#1.#3}}

\lstloadlanguages{Matlab}
\lstset{language=Matlab,
	frame=single,	% Frame type around code
	basicstyle=\small\ttfamily,	% Basic code style
	keywordstyle=[1]\color{Blue}\bf,	% Python functions bold and blue
	keywordstyle=[2]\color{Purple},	% Python function arguments purple
	keywordstyle=[3]\color{Blue}\underbar,	% User functions underlined and blue
	identifierstyle=,	% Nothing special about identifiers
	commentstyle=\usefont{T1}{pcr}{m}{sl}\color{DarkGreen}\small,	% Comment style
	stringstyle=\color{Purple},	% String style
	showstringspaces=false,	% Space string indication
	tabsize=2,
%	escapechar={},
	breaklines=true,
	breakautoindent=false,
	prebreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\space\color{red}{\blacktriangledown}\color{blue}\thelstnumber}},
	postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{blue}\thelstnumber\color{red}{\blacktriangle}\space}},
	morekeywords={xlim, ylim, },	% Not default functions
	morekeywords=[2]{on, off},	% Custom function parameters
	morekeywords=[3]{FindESS},	% Custom functions
	morecomment=[l][\color{Blue}]{...},	% Line continuation (...) like blue comment
	numbers=left,
	numberfirstline=true,
	firstnumber=1,	% Line number offset
	numberstyle=\tiny\color{Blue},	% Line numbers
	stepnumber=5	% Line numbers step
}


% % % Configuration
\graphicspath{{./}{Graphics/}}
%\renewcommand{\figurename}{Wykres}
%\renewcommand{\figurename}{Figure}
%\renewcommand{\figurename}{Image}
%\renewcommand{\tablename}{Tabela}
%\renewcommand{\lstlistingname}{Skrypt}
\renewcommand{\lstlistingname}{Script}


% % % Specific Information
\newcommand{\Code}{86805}
\newcommand{\Title}{Software Architectures for Robotics}
\newcommand{\SubTitle}{Localization system for a wheeled humanoid robot}
\newcommand{\Date}{01.02.16}
\newcommand{\Time}{Wed 23:55}
\newcommand{\Recipient}{Prof. F. Mastrogiovanni, PhD C. Recchiuto}
\newcommand{\Author}{Rabbia Asghar, BEng, Ernest Skrzypczyk, BSc}


% % % Document margins
\topmargin = -0.45in
\evensidemargin = 0in
\oddsidemargin = 0in
\textwidth = 6.5in
\textheight = 9.0in
\headsep = 0.25in


% % % Setup the header and footer
\pagestyle{fancy}
\lhead{\Author}
\chead{\Code: \Title, \Recipient\\} %(\Time,\ \Date)}  %
\rhead{\firstxmark}
\lfoot{\lastxmark}
\cfoot{}
\rfoot{Page\ \thepage/\protect\pageref{LastPage}}
\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}
\setlength{\parindent}{4ex}


% % % Colors
\definecolor{DarkGreen}{rgb}{0.0,0.4,0.0}


% % % Debugging
%\tracingall


% % % % CLEAN UP
% % % Style specific commands and configuration
%\newcommand{\enterProblemHeader}[1]{\nobreak\extramarks{#1}{#1 kontynuowany na następnej stroniecontinued on next page\ldots}\nobreak%
%												\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak}
%\newcommand{\exitProblemHeader}[1]{\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak%
\newcommand{\enterProblemHeader}[1]{\nobreak\extramarks{#1}{#1\ldots}\nobreak%
	\nobreak\extramarks{#1 (continued)}{#1}\nobreak}
\newcommand{\exitProblemHeader}[1]{\nobreak\extramarks{#1 (continued)}{#1}\nobreak%
	\nobreak\extramarks{#1}{}\nobreak}

\newlength{\labelLength}
\newcommand{\labelAnswer}[2]
	{\settowidth{\labelLength}{#1}
	\addtolength{\labelLength}{0.25in}
	\changetext{}{-\labelLength}{}{}{}
	\noindent\fbox{\begin{minipage}[c]{\columnwidth}#2\end{minipage}}
	\marginpar{\fbox{#1}}

	% We put the blank space above in order to make sure this
	% \marginpar gets correctly placed.
	\changetext{}{+\labelLength}{}{}{}}

\setcounter{secnumdepth}{0}
\newcommand{\ProblemName}{}
\newcounter{ProblemCounter}
\newenvironment{Problem}[1][Problem \arabic{ProblemCounter}]%
	{\stepcounter{ProblemCounter}
	\renewcommand{\ProblemName}{#1}
	\section{\ProblemName}
	\enterProblemHeader{\ProblemName}}
	{\exitProblemHeader{\ProblemName}}

\newcommand{\problemAnswer}[1]
	{\noindent\fbox{\begin{minipage}[c]{\columnwidth}#1\end{minipage}}}

\newcommand{\problemLAnswer}[1]
	{\labelAnswer{\ProblemName}{#1}}

\newcommand{\SectionName}{}
\newlength{\SectionLabelLength}{}
\newenvironment{Section}[1]
	{\renewcommand{\SectionName}{#1}
	\settowidth{\SectionLabelLength}{\SectionName}
	\addtolength{\SectionLabelLength}{0.25in}
	\changetext{}{-\SectionLabelLength}{}{}{}
	\subsection{\SectionName}
	\enterProblemHeader{\ProblemName\ [\SectionName]}}

{\enterProblemHeader{\ProblemName} \changetext{}{+\SectionLabelLength}{}{}{}}

\newcommand{\sectionAnswer}[1]
{
	\noindent\fbox{\begin{minipage}[c]{\columnwidth}#1\end{minipage}}
	\enterProblemHeader{\ProblemName}\exitProblemHeader{\ProblemName}
	\marginpar{\fbox{\SectionName}}
}

%% Edits the caption width
%\newcommand{\captionwidth}[1]{%
%  \dimen0=\columnwidth	\advance\dimen0 by-#1\relax
%  \divide\dimen0 by2
%  \advance\leftskip by\dimen0
%  \advance\rightskip by\dimen0
%}
% % % % CLEAN UP


% % % % CLEAN UP
% % % Title page
\title{\vspace{2in}\textmd{\textbf{\Code:\ 
\Title\ifthenelse{\equal{\SubTitle}{}}{}{\\\SubTitle}}} \\\normalsize\vspace{0.1in}\small{Date:\ 
\Time,\ \Date} \\\vspace{0.1in}\large{\textit{\Recipient}}\vspace{3in}}
\date{}
\author{\textbf{\Author}}
% % % % CLEAN UP


% % % Document
\begin{document}
\begin{spacing}{1.1}
\maketitle


% % % Table of contents
\setcounter{tocdepth}{2}
\tableofcontents
\listoffigures
%\listoftables
\newpage
%\setcounter{page}{1}

% % % Text
\begin{Problem}[Rollo - Humanoid robot]
\section{Odometry}\label{s:10-odometry}
\indent\indent
Odometry is one of the most widely used technique for determining the position of a mobile robot
%TODO "one of" makes it a safe statement without references. Old ones are good enough. I don't know how if to implement the references like these footnotes. Is this good? Should I add author. I don't want to make a bibliography for this.
\footnote{\link[UMBmark -- A Method for Measuring, Comparing, and Correcting Odometry Errors in Mobile Robots]{http://www-personal.umich.edu/~johannb/umbmark.htm}}
\footnote{\link[Comparative Study of Localization Techniques for Mobile Robots based on Indirect Kalman Filter]{http://www.ual.es/personal/rgonzalez/papers/ramon-gonzalez-isr09.pdf}}
.
%old papers though
%http://www-personal.umich.edu/~johannb/umbmark.htm
%http://www.ual.es/personal/rgonzalez/papers/ramon-gonzalez-isr09.pdf
It mainly involves use of various encoders, for example on wheels, as sensors to estimate the robot's position relative to a starting or previous location. Usually, it is used for real-time positioning in the between the periodic absolute position measurements, for example \link[GPS (Global Positioning System)]{http://www.gps.gov/} provides absolute position feedback, however it updates at $0.1 \div 1 s$ interval, during which odometry could be used for localization. %ALT / for estimating current position
% Odometry is used to estimate position during its update interval. %REP
%The reason for its popularity is it's simplicity and the straight forward approach ot its implementation. However, this comes at a cost
One of the major downsides of odometry is its sensitivity to errors. There are various error sources discussed in section \nameref{s:10-odometry--errors} \vpageref{s:10-odometry--errors} in detail. One significant source of error influencing the accuracy of odometry that is worth mentioning however, is the integration of velocity measurements over time to give position estimates.

First the odometry based physical motion model for the robot will be derived. The model is derived based on the following important assumptions:

\begin{enumerate}
	\item The robot is a rigid body
	\item The model represents a differential drive robot
	\item The wheels of the robot are perfect discs and have the same diameters
	\item The wheels have no thickness
	\item There is no slip in the wheels %TODO Q I'm not sure "slip" is the correct word here, check dictionary reference; Ok, TODO can be deleted
	\item Both wheels are turning in the forward direction
\end{enumerate} 

A differential drive robot runs straight when the linear speed of both the left and right wheel is same. If the speed of one wheel is greater than the other, the robot runs in an arc. This derivation can be divided in three distinct cases of robot motion:

\begin{enumerate}
	\item Clockwise direction
	\item Counterclockwise direction
	\item Straight line
\end{enumerate}

The basic premise for the odometry model of the Rollo humanoid robot is presented in figures \fref{10-odometry-rt-2w} and \fref{10-odometry-lt-4w}.

%\includesvg[0.75]{Graphics/10-odometry--left-turn}{Odometry model with the simplified 2 wheel configuration for the right turn.\label{f:10-odometry-lt-2w}}
\includesvg[0.75]{Graphics/10-odometry--right-turn}{Odometry model with the simplified 2 wheel configuration for the right turn.\label{f:10-odometry-rt-2w}}

%\includesvg[0.75]{Graphics/10-odometry--right-turn--4-wheels}{Odometry model with the simplified 4 wheel configuration for the right turn.\label{f:10-odometry-rt-4w}}
\includesvg[0.75]{Graphics/10-odometry--left-turn--4-wheels}{Odometry model with the simplified 4 wheel configuration for the left turn.\label{f:10-odometry-lt-4w}}

\subsection{Clockwise direction}\label{s:10-odometry--cw}
\indent\indent
First the case is considered, when the speed of left wheel is greater than the right and the robot will run in clockwise direction. Both right and left wheel will rotate around the same center of a circle. %TODO How about making the origin of the circles in the drawings and refer to them?

$P_i$ represents the initial position of the robot defined by the center of the line joining two wheels, while $l$ represents wheel base, ergo distance between or axle length of two wheels. $S_L$ and $S_R$ represent the distance travelled by left and right wheel respectively.
$\Delta \Theta$ represents the angle of travel for both the wheels and $r$ is the radius of travel from the center of robot. 
With encoder feedback from left and right wheel, $S_L$ and $S_R$ can simply be computed using equations \eref{e:SL} and \eref{e:SR}

\begin{equation}\label{e:SL}
	S_L = \frac{n_L}{60} 2 \pi r_L t
\end{equation}

\begin{equation}\label{e:SR}
	S_R = \frac{n_R}{60} 2 \pi r_R t
\end{equation}

where $n_L$ and $n_R$ are the revolutions per minute ($[rpm]$) of left and right wheel, $r_L$ and $r_R$ are the radii of the two wheels and $t$ is time step in seconds. %TODO Legend table might be better, but leave it as it

$S_L$ and $S_R$ can be related to $r$ and $\Delta \Theta$ using formulas \eref{e:SL=rtheta} and \eref{e:SR=rtheta}

\begin{equation}\label{e:SL=rtheta}
	S_L = (r + \frac{l}{2}) \Delta \Theta
\end{equation}

\begin{equation}\label{e:SR=rtheta}
	S_R = (r - \frac{l}{2}) \Delta \Theta 
\end{equation}

The equations \eref{e:SL=rtheta} and \eref{e:SR=rtheta} \vpageref[above]{e:SL=rtheta} can be solved simultaneously to compute $\Delta \Theta$ defined in \eref{e:thetaCW}.

%\begin{equation}\label{e:r}
%	r  = \frac{l}{2} \cdot \frac{S_L + S_R}{S_L - S_R} % Travel distance
%\end{equation}

\begin{equation}\label{e:thetaCW}
	\Delta \Theta = \frac{S_L - S_R}{l} % Travel angle
\end{equation}

The length between initial position $P_i$ and final position $P_f$ can be approximated by taking average of $S_L$ and $S_R$. %\eref{e:delS}.

\begin{equation}\label{e:delS}
	\Delta S = \frac{S_L + S_R}{2} % del S 
\end{equation}

Final position of the robot $P_f$ and its orientation $\Theta_f$ can then be derived using basic trigonometry and geometry relations as shown in figure \fref{10-odometry--movement} and portrayed in equation \eref{e:P_fCW}. In general case the length of arc $S$ connecting $P_i$ and $P_f$ can be approximated as $\Delta S$. This is because $\Delta S$ is very convenient to compute from encoders feedback and the two lengths are almost equal for a very small movements and step of time. This is basically the same technique used to compute $\pi$ or similar analogue to digital conversion problems. Should the time step increase however, then the error between $S$ and $\Delta S$, represented as red area, will grow, making the approximation very inaccurate.

\includesvg[0.75]{Graphics/10-odometry--movement}{Odometry model derivation using trigonometry for computation of position and orientation during movement.\label{f:10-odometry--movement}}

\begin{IEEEeqnarray}{CCC}\label{e:P_fCW}
	P_f  & = & 
	\begin{bmatrix}
		P_{ix} + \Delta S ( \cos(\Theta_i - \frac{\Delta \Theta}{2}) ), & P_{iy} + \Delta S ( \sin(\Theta_i - \frac{\Delta \Theta}{2}) )
	\end{bmatrix}
\end{IEEEeqnarray}
\nopagebreak %TODO doesn't seem to work. Layout will change with graphics, so don't bother now. \mbox and \makebox don't compile
\begin{equation*}\label{e:finalorientationCW}
	\mathrm{\Theta_f = \Theta_i - \Delta \Theta}\nonumber %TODO This technique of seperation of equations is unfortunate, since it allows page breaks between them and the number is not centered. There are other approaches to have one equation number for multiple equations. Another possibility would be to use cleverref. Going to leave it as it is, too time consuming for now. http://stackoverflow.com/questions/3328806/latex-multiple-equation-references-in-one
\end{equation*}
%TODO Don't fully understand your mathrm approach here. What is the purpose? Theta is another variable, so it changes. Parameters in equations that don't change should be straight, those that do change should be italic. So the normal approach is correct. Assume you wanted \Theta straightforward for cosmetic reasons. Leave it as it is.
where $\Theta_f$ and $\Theta_i$ are the final and initial orientation respectively.

\subsection{Counterclockwise direction}\label{s:10-odometry--ccw}
\indent\indent
Similar derivation of the robot can be derived for counterclockwise rotation, when the revolutions per minute of right wheel are higher than that of the left wheel. $\Delta \Theta$ can be computed as shown in \eref{e:thetaCCW}

\begin{equation}\label{e:thetaCCW}
\Delta \Theta = \frac{S_R - S_L}{l} % Travel angle
\end{equation}

The relations for final position and rotation are as follows \eref{e:P_fCCW}.

\begin{IEEEeqnarray}{CCC}\label{e:P_fCCW}
	P_f  & = & 
	\begin{bmatrix}
		P_{ix} + \Delta S ( \cos(\Theta_i + \frac{\Delta \Theta}{2}) ), & P_{iy} + \Delta S ( \sin(\Theta_i + \frac{\Delta \Theta}{2}) )
	\end{bmatrix}\end{IEEEeqnarray}
\nopagebreak %TODO doesn't seem to work. Layout will change with graphics, so don't bother now
\begin{equation*}\label{e:finalorientationCCW}
	\mathrm{\Theta_f = \Theta_i + \Delta \Theta}\nonumber
\end{equation*}

where $\Theta_f$ and $\Theta_i$ are the final and initial orientation respectively.

\subsection{Straight line motion}\label{s:10-odometry--straight-line-motion}
\indent\indent
%In case of straight line motion, the orientation of the robot stays the same. Thus, $\Theta$ in this case is 0. Also, $S_L$ is the same as $S_R$.
In case of straight line motion, the orientation of the robot stays the same, therefore $\Delta \Theta$ in this case is $0$ and $S_L$ is the same as $S_R$.
%TODO Left the original so you can switch if you want. http://english.stackexchange.com/questions/44369/start-a-subordinate-clause-with-thus
The relations for final position and rotation are as follows:

\begin{IEEEeqnarray}{CCC} \label{e:P_fSt}
	P_f  & = & 
	\begin{bmatrix}
%		P_{ix} + S_L( \cos(\Theta_i) ), & P_{iy} + S_L \sin(\Theta_i)
		P_{ix} + S_{L=R} \cos(\Theta_i), & P_{iy} + S_{L=R} \sin(\Theta_i) %TODO Changed index to emphasize the equivalency between the two
	\end{bmatrix}
\end{IEEEeqnarray}
\nopagebreak %TODO doesn't seem to work. Layout will change with graphics, so don't bother now
\begin{equation*}\label{e:finalorientationSt}
	\mathrm{\Theta_f = \Theta_i }\nonumber
\end{equation*}

\subsection{Final set of equations}\label{s:10-odometry--final-equations-set}
\indent\indent
With the derivation of formulas understood for all three cases, for the ease of computation it is desirable to have the same set of equations in all cases.

The equations selected for this model are as follows.

\begin{equation}\label{e:thetaCWfinal}
	\Delta \Theta = \frac{S_L - S_R}{l} % Travel angle
\end{equation}

\begin{equation}\label{e:delSfinal}
	\Delta S = \frac{S_L + S_R}{2} % del S 
\end{equation}

\begin{IEEEeqnarray}{CCC}\label{e:P_fCWfinal}
	P_f  & = & 
	\begin{bmatrix}
		P_{ix} + \Delta S ( \cos(\Theta_i - \frac{\Delta \Theta}{2}) ), & P_{iy} + \Delta S ( \sin(\Theta_i - \frac{\Delta \Theta}{2}) )
	\end{bmatrix}
\end{IEEEeqnarray}

\begin{equation}\label{e:finalorientationCWfinal}
\mathrm{\Theta_f = \Theta_i - \Delta \Theta}\nonumber
\end{equation}

The standalone Python script \verb|rollo_compute_position.py| can provide further details on the odometry model.

%TODO CHECKED
\subsection{Adaptation of odometry model for Rollo}\label{s:10-odometry--rollo}
\indent\indent
During the project realization the encoders feedback was unavailable in the robot and a physical odometry model could not have been implemented. However, an attempt has been made to implement its modified version. In absence of encoders feedback, the distance covered by left and right wheels is instead estimated from the control command. %TODO Realtime has a specific definition, this is not realtime, neither soft or hard

In order to implement this simplification initial tests were conducted with Rollo.
%TODO I would like to insert this reference http://www.ecse.monash.edu.au/centres/irrc/LKPubs/MECSE-1995-1.pdf from http://biorobotics.ri.cmu.edu/papers/sbp_papers/integrated3/kleeman_kalman_basics.pdf (slide 35), even though it was performed for estimating covariance, I would say it is still related. You also used arcs for this, so I changed the below a little.
The robot was run in a straight line, constant curvature arcs and performed rotations at different commands. Rollo's location feedback from the motion capture system was logged. For a given command, average speed of left and right wheel was determined from the recorded data. Matlab environment was used to perform analysis of logged data according to following algorithm:

\begin{enumerate}
	\label{a:command-velocities-estimation-algorithm}
	\item The position in $x$ and $y$ coordinates of Rollo was plotted along with \emph{line of best fit} for the data set.
	\item For the displacement of the robot total distance travelled by the robot and change in orientation was determined using the \emph{line of best fit}.
	\item Using the timestamps from the recorded data, distance travelled and change in orientation were determined for a unit of time. %TODO Maybe I misunderstood "unit of time"
%%	\item The rotation speeds of the wheels were determined using the relation in equations \eref{e:SL} through \eref{e:delS}. %TODO This is digital, using rpm does not really serve descriptive purpose
	\item The rotation speeds of the wheels were determined using the relation in equations \eref{e:SL} $\div$ \eref{e:delS}. %TODO This is digital, using rpm does not really serve descriptive purpose
\end{enumerate}

The above procedure is based on the assumption that there was no linear acceleration at a given velocity command and the rate of change of robot's orientation was constant. %TODO Shouldn't that be stated before the procedure then? Its fine both above and below. TODO Can be delted then.

%The procedure was repeated for clockwise and counterclockwise rotation of the robot.
%TODO I changed the above, so this should match. Maybe merging the sentences into one paragraph would be wise
For simplicity only the forward motion was modelled.

Table \tref{command-velocities-estimates} shows the predetermined angular velocities of the wheel for given command velocities determined according to the \vpageref[above]{a:command-velocities-estimation-algorithm} algorithm. %TODO Using reference naming conventions, so t for table, number of table afterwards, using double digits

%\begin{table}
%	\centering
%	\caption{Predetermined wheels angular velocity based on test logs for given forward command.}
%	\label{t:command-velocities-estimates}
%	\begin{tabular}{| >{\centering\arraybackslash}p{3cm} | >{\centering\arraybackslash}p{3cm} | >{\centering\arraybackslash}p{3cm} | >{\centering\arraybackslash}p{3.5cm} |}
%		\hline %TODO The above is not necessary, X and Y have been both declared for tabularx, but leave it as it is.
%%		Velocity command left [\%] & Velocity command right [\%] & Left wheel angular velocity [rad/s] & Right wheel angular velocity [rad/s] \\ \hline %TODO Add symbols here, descriptions are welcome
%		Velocity command & Velocity command & Angular velocity & Angular velocity \\
%%		\hline
%%		Left $v_L$ [\%] & Right $v_R$ [\%] & Left $n_L$ [rad/s] & Right $n_R$ [rad/s] \\
%		left $v_L$ [\%] & right $v_R$ [\%] & left $n_L$ [rad/s] & right $n_R$ [rad/s] \\
%		\hline %TODO Added symbols here, descriptions are welcome
%		\hline
%		6 & 6 & 1.381 & 1.382 \\ \hline
%		12 & 12 & 9.530 & 9.531 \\ \hline
%		19 & 19 & 16.729 & 16.736 \\ \hline
%		56 & 56 & 32.040 & 31.250 \\ \hline
%		12 & 19 & 11.778 & 11.998 \\ \hline
%		19 & 12 & 11.978 & 11.720 \\ \hline
%		31 & 38 & 27.974 & 28.113 \\ \hline
%		31 & 31 & 23.798 & 23.684 \\ \hline
%	\end{tabular}
%\end{table}

%TODO Added symbols, even though the units might not match the previous descriptions directly, I suggest to leave it, since it is still correct
%TODO Choose one of the tables, I would suggest the latter for formatting benefits that come with page changes for example, but it's up to you. Comment the other one out

%\makebox[\textwidth][c]{ %TODO Choose which ever you prefer, format can be fixed. Need a few more minutes on this
	\begin{table}[h]
		\centering
		\caption{Predetermined wheels angular velocity based on test logs for given forward command.}
		\label{t:command-velocities-estimates}
		\begin{tabularx}{0.8\textwidth}{@{}|Y|Y|Y|Y|@{}}
			\hline \multicolumn{2}{|c|}{Velocity command} & \multicolumn{2}{c|}{Angular velocity} \\
				\hline
				Left $v_L$ [\%] & Right $v_R$ [\%] & Left $n_L$ [rad/s] & Right $n_R$ [rad/s] \\
				\hline %TODO Added symbols here, descriptions are welcome
				\hline
				6 & 6 & 1.381 & 1.382 \\ \hline
				12 & 12 & 9.530 & 9.531 \\ \hline
				19 & 19 & 16.729 & 16.736 \\ \hline
				56 & 56 & 32.040 & 31.250 \\ \hline
				12 & 19 & 11.778 & 11.998 \\ \hline
				19 & 12 & 11.978 & 11.720 \\ \hline
				31 & 38 & 27.974 & 28.113 \\ \hline
				31 & 31 & 23.798 & 23.684 \\ \hline
		\end{tabularx}
	\end{table}
%}

\subsubsection{Challenges in the modelling of Rollo}\label{s:10-odometry--rollo--challenges}
%\indent\indent
\begin{enumerate}
	\item Due to the mechanical differences in the two legs of Rollo, it is almost impossible for the two wheels to run at the same speed. Moreover, the two motors are powered using two different battery packs and are run in open loop. The difference in voltage level of battery packs results in a different current at the same velocity command using pulse-width modulation increasing the overall velocity error. %TODO Just expanded a little

	\item The robot randomly skids and changes its orientation even for a straight line run. This is partly due to mechanical properties of the robot, partly due to the surface of the laboratory, which serves as testing area and is uneven. The rubber of the tyres lacks sufficient grip on the floor to prevent skidding. One of the Rollo's wheels is visibly skewed. This is a major source for deviation in behaviour of robot's adjusted odometry model. %TODO Minor changes

	\item The odometry model is based on the assumption that the wheels have no thickness and have only one point of contact with ground surface. Rollo has four powered wheels by two motors, where each wheel is a $4 cm$ thick. Additionally there are four support wheels in front and back of the two major wheel sets, so that Rollo does not fall over. % TODO How much is "few centimeters"? I suggest putting a value 4 cm. Expanded a little
\end{enumerate}

%TODO CHECKED

\subsection{Odometry errors}\label{s:10-odometry--errors} %TODO refine the whole subsection, define systematic and random errors, shows the differences and the influence on the overall error
\indent\indent
As briefly discussed above, odometry is very sensitive to errors. However, results of odometry based models can be improved by rapid and accurate data collection, equipment calibration and processing of acquired data. %TODO Processing of what? I assume acquired data

The sources of odometry errors can be broadly divided into two categories:
\begin{enumerate}
%	\item systematic errors,
%	\item non-systematic errors.
	\item Systematic errors
	\item Non-systematic errors
\end{enumerate}

\subsubsection{Systematic errors}\label{s:10-odometry--errors--systematic}
\indent\indent
Systematic errors are caused by inherent properties of the system. They are usually the result of imperfections in the design, production and mechanical construction of a mobile robot and it's components. In ideal environment conditions, like most smooth indoor surfaces, systematic errors play a much bigger role in than non-systematic errors. Systematic errors also accumulate constantly over time. %TODO Expanded a little

%TODO Included into given contex
In general case there are three main sources of systematic errors in odometry of wheeled robots during a robot's movement:
\begin{itemize}
	\item Distance
	\item Rotation
	\item Skew
\end{itemize}

Distance error accumulates with the robot travelling. Rotation and skew errors are of less significance with small distance and speed movements, however they are usually dominant with time and influence the overall error more than the distance error.

The major sources of the systematic error in an odometry model of a wheeled robot from a mechanical point of view are unequal diameters of wheels and the uncertainty about the effective wheelbase.
Rollo consists of four plastic tyres covered in rubber stripes, two wheels on each side with additional four supporting wheels preventing Rollo from falling over. 

%TODO insert an image of Rollo showing wheel construction here

%Rubber on tyres helps improve traction, however at the same time it is difficult to manufacture with exactly the same diameter. Another aspect is that with time rubber tyres compress differently under asymmetric load distribution. Their diameters are used in computing $S_L$ and $S_R$ as previously shown in equations \eref{e:SL} and \eref{e:SR}.
Rubber on tyres helps improve traction, however with time rubber compresses differently under asymmetric load distribution. The diameters of wheels are used in computing $S_L$ and $S_R$ as shown in equations \eref{e:SL} and \eref{e:SR}. %TODO Rollo does not have rubber tyres, it has plastic tyres with rubber stripes on them. Changes tires to tyres, since it looks like Rollo is tired.

Furthermore, the contact area between the wheels of Rollo and the floor is comparatively wide for a robot of it's size. %TODO Now the size should be at least estimated
This introduces difficulties in determining the wheelbase of the robot. Wheelbase is used in computation of angle of travel $\Delta \Theta$ as shown in 
%equations \eref{e:thetaCW} and \eref{e:thetaCCW}.
equation \eref{e:thetaCWfinal}. %TODO Left only the final equation as reference

Other examples of sources of mechanical errors include:

\begin{itemize}
	\item Average of both wheel diameters differ from nominal diameter
	\item Misalignment of wheels
%	\item Asymmetrical wheel axes %TODO Basically the same thing
	\item Unbalanced wheels
%	\item Limited resolution during integration (encoder sampling rate and digital to analog converter resolution)
	\item Digitalization of acquired data (encoder sampling rate and digital to analog converter resolution) %TODO Is that what was meant here?
\end{itemize}

\subsubsection{Non-systematic errors}\label{s:10-odometry--errors--non-systematic}
\indent\indent
Non-systematic errors are caused by unknown or unpredictable changes in the system and in the environmental conditions.
In wheeled mobile robots, they are usually caused by uneven floors, like in the case of testing area of Rollo. On rough surfaces with significant irregularities, non-systematic errors may be more dominant over systematic errors. On contrary to systematic errors, non-systematic errors do not accumulate with time, but occur randomly.

Possible examples of non-systematic errors are:

\begin{itemize} %TODO Don't use enumerate lists with examples, since they do not cover all possible cases, enumarating them seems pointless. Those are bulletpoint examples
	\item Travel over uneven floors or unexpected objects on the floor
	\item Wheelslip due to: %TODO https://en.wikipedia.org/wiki/Wheelspin
	\begin{itemize}
		\item Slippery floors
		\item Over-acceleration
		\item Fast turning (skidding)
%		\item Non-point wheel contact with the floor
		\item Temporal loss of wheel contact with the floor
	\end{itemize}
\end{itemize}

%TODO CHECKED

\subsection{Measuring odometry errors}\label{s:10-odometry--measuring-odometry-errors}
\indent\indent
University of Michigan Benchmark test (UMBmark) procedure was supposed to be used to determine odometry errors and calibrate the provided system. This procedure was developed by Johann Borenstein and Liqiang Feng around 1995 at the University of Michigan’s Advanced Technologies Laboratories. Further details of the test can be found in the research paper \link[UMBmark: A Benchmark Test for Measuring Odometry Errors in Mobile Robots]{http://www.johnloomis.org/ece445/topics/odometry/borenstein/paper60.pdf}. %TODO Is this link ok as referance like that?

As discussed in \nameref{s:10-odometry--errors--systematic} \vref{s:10-odometry--errors--systematic}, there are two dominant sources of systematic errors in odometry: unequal wheel diameters and the uncertainty about the effective wheelbase. %TODO Can't seem to \ref section number
%As discussed in \ref{s:10-odometry--errors--systematic} \nameref{s:10-odometry--errors--systematic} \vref{s:10-odometry--errors--systematic}, there are two dominant sources of systematic errors in odometry: unequal wheel diameters and the uncertainty about the effective wheelbase. %TODO Can't seem to \ref section

Unfortunately, due to unavailability of encoder feedback estimations of $S_L$ and $S_R$ are done using the command given to the robot, so the control input. This means, that equations \eref{e:SL} and \eref{e:SR} are not used in the modified model. %TODO I think it's a good point to state, so I uncommented it

Even if it should be possible to determine the error in the relative size of the wheels and the error due to the uncertainty in effective wheelbase, those can not be corrected or calibrated in the current model. However, the details of the procedure to determine effective wheelbase are described in this section.

%An incorrect wheelbase value will result in incorrect computation of angle of travel, $\Delta\theta$ refer to \eref{e:thetaCWfinal}.
As can be seen in the equation \eref{e:thetaCWfinal}, incorrect wheelbase value will introduce a significant error in computation of angle of travel $\Delta \Theta$.
This error $E_b$, is directly proportional to the effective wheelbase in relation to the nominal wheelbase $l$: %TODO division is a relation and is somewhat more descriptive here. Alternatively one could write it's also inversly proportional to nominal wheelbase

\begin{equation}\label{e:E_b}
%	E_b = \frac{l_e}{l}
%	E_b = \frac{b_e}{l}
	E_b = \frac{effective wheelbase}{l} %TODO I suggest introducing l_e or like you choose b_e as effective wheelbase and then writing what the symbol stands for
\end{equation}

After computing error $E_b$, the nominal wheelbase in equation \eref{e:thetaCWfinal} can be replaced by effective wheelbase. Thus, this error can be corrected by multiplying the nominal wheelbase $b_n$ with the error factor $E_b$ resulting in the effective wheelbase $b_e$: %TODO What is "this error" and "error factor" referring to? Both seem to refer to E_b, which makes the sentence confusing. Double check if meaning is correct. Maybe writing the process would be better. Nominal wheelbase would be l here, yet you use b_n. It's somewhat confusing

\begin{equation}\label{e:thetacalibrated}
	\Delta \Theta = \frac{S_L - S_R}{E_b \cdot l} % Travel angle
\end{equation}

The error $E_b$ can be determined using UMBmark square test procedure, whose summary for Rollo is as follows: %TODO simplified a little

\begin{enumerate} %TODO I changed the text to differentiate at least a little from the source
	\item At the beginning of or before the actual run, measurements of the absolute position and orientation of Rollo using motion capture system are performed along with initialization of vehicle's odometry program to the starting point.
	\item Running the vehicle through a $2 \times 2 \ m$ square path in clockwise direction while making sure to:
	\begin{enumerate} %TODO I know it's a pain with units, but ISO states there must be a space between value and unit, except for degree, minute and second symbols (°,','')
		\item stop after each $2 \ m$ straight segment,
		\item make a total of four $90\degree$-turns on the spot,
		\item run the vehicle slowly to avoid slippage.
	\end{enumerate}
	\item After returning to the starting area, again measurements of the absolute position and orientation of Rollo are performed using motion capture system.
	\item Comparing between the absolute position and robot's calculated position using equations \eref{e:x_error}, \eref{e:y_error} and \eref{e:orientation_error}.

	\begin{equation}\label{e:x_error} %TODO We are dealing here with errors, those should be additive, so maybe we should take a squareroot of difference of square of abs and calc values
			\epsilon x = x_{abs} - x_{calc}
	\end{equation}
	
	\begin{equation}\label{e:y_error}
		\epsilon y = y_{abs} - y_{calc}
	\end{equation}
	
	\begin{equation}\label{e:orientation_error}
		\epsilon \theta = \theta_{abs} - \theta_{calc}
	\end{equation}

%TODO Added description from paper just to make it more clear, comment out if you think it's unnecessary
	\begin{description}
		\centering
		\item[$\epsilon x$, $\epsilon y$, $\epsilon \theta$] -- Position and orientation errors due to odometry model
		\item[$x_{abs}$, $y_{abs}$, $\theta_{abs}$] -- Absolute position and orientation of Rollo
			\item[$x_{calc}$, $y_{calc}$, $\theta_{calc}$] -- Calculated position and orientation of Rollo using odometry model
	\end{description}

	\item Repetition of steps $1 \div 4$ for four more times, giving a total of five runs.
	\item Repetition of steps $1 \div 5$ in counterclockwise direction.
	\item Computation of center of gravity coordinates for each cluster in clockwise and counterclockwise directions using equations \eref{e:cog_x} and \eref{e:cog_y}, where $n$ is the number of runs, so $n = 5$ in the proposed scenario.

%TODO Don't see the point of using exactly the same indices. Here the problem with negative errors is really apparent. We cannot have positive and negative errors, they always add up.
	\begin{equation}\label{e:cog_x}
%		x_{c.g., cw/ccw} = \frac{1}{n}\sum_{i=1}^{n} \epsilon x_{i, cw/ccw} 
		x_{cg, cw/ccw} = \frac{1}{n}\sum_{i=1}^{n} \epsilon x_{i, cw/ccw} 
	\end{equation}

	\begin{equation}\label{e:cog_y}
%		y_{c.g., cw/ccw} = \frac{1}{n}\sum_{i=1}^{n} \epsilon y_{i, cw/ccw}
		y_{cg, cw/ccw} = \frac{1}{n}\sum_{i=1}^{n} \epsilon y_{i, cw/ccw}
	\end{equation}

	\item Computation of $E_b$ using equations \eref{e:E_b_alpha},\eref{e:alpha_x} and \eref{e:alpha_y}

	%	\item Use Eqs. (2) and (3) to express the experimental results quantitatively as the measure of odometric accuracy for systematic errors, Emax,syst.
	
	%	\item If an estimate for the vehicle’s susceptibility to non-systematic errors is needed, then perform steps 1-6 again, this time placing a round
	%	10 mm diameter object (for example, an electrical household cable) under the inside wheel of the robot. The object must be placed there	10 times, during the first leg of the square path.
	%	\item Compute the average absolute orientation error
	%TODO I can add the equation 3 from paper and complete this part. Just tell me

	\begin{equation}\label{e:E_b_alpha}
		E_b = \frac{90\degree}{90\degree - \alpha}
	\end{equation}

	where $\alpha$ can be defined as 

	\begin{equation}\label{e:alpha_x}
		\alpha =  \frac{x_{cg, cw} + x_{cg, ccw}}{-4L} \frac{180\degree}{\pi}
	\end{equation}

	or

	\begin{equation}\label{e:alpha_y}
		\alpha =  \frac{y_{cg, cw} - y_{cg, ccw}}{-4L} \frac{180\degree}{\pi}
	\end{equation}

	and $L$ represents the side of square segment, for the given test area conditions in case of Rollo $L = 2 \ m$.

\end{enumerate} %TODO This is all part of the enumeration, so I've put it here

%TODO CHECKED


\clearpage
\section{System and measurements model}\label{s:20-system-and-measurement-model}
%[REFERENCE] http://www.negenborn.net/kal_loc/	
%http://www.negenborn.net/kal_loc/thesis.pdf
%TODO How do you propose to make the reference? A footnote like before?
\subsection{System model}\label{s:20-system-and-measurement-model--system-model}
\indent\indent
In order to implement Kalman filter\footnote{\link[Rudy Negenborn - Robot Localization and Kalman Filters]{http://www.negenborn.net/kal_loc/thesis.pdf}}, the previously described model must be first represented in state space.
%TODO I know he uses Kalman Filter instead of Kalman filter
Location of the robot can be defined at instant $k$ using state variables \eref{e:xk localistion}, which include position in $x$ and $y$ coordinates and orientation $\Theta$. %TODO Inconsistency with previous \Theta, but leave as is

\begin{IEEEeqnarray}{CCCCCCCCC} \label{e:xk localistion} %TODO All labels must not have whitespaces and special symbols in them. Correct later
	x_k & = & 
	\begin{bmatrix}
		x_{[x], k} \\
		x_{[y], k} \\
		x_{[\theta], k} \\
	\end{bmatrix}
\end{IEEEeqnarray}

The control input provided to robot consists of left and right wheel speeds. This defines the distance covered by both the wheels in a given unit of time. The relative displacement of the robot at instant $k$ can be notated by $d_k$. Using equations \eref{e:P_fCW}, \eref{e:P_fCCW} and \eref{e:P_fSt}, derived on page \vpageref{e:P_fCW}, relative displacement can be expressed in terms of $\Delta S$ and $\Delta \Theta$. Thus, control input $u_k$ can be expressed as a function of relative displacement $d_k$. %TODO consists or includes. Now the problem with inconsistent naming of theta comes up. I suggest using one for the whole document. Simply regex replace the whole thing *inside* document environment, not for the whole file.

\begin{equation} \label{e:uk displacmenet}
	u_k  =  j(d_k)
\end{equation}

\begin{IEEEeqnarray*}{CCCCCCCCC}\label{e:uk displacement2}
	u_k & = & 
	\begin{bmatrix}
		u_{[\Delta S], k} \\
		u_{[\Delta \theta], k} \\
	\end{bmatrix}
\end{IEEEeqnarray*}

Given $x_{k-1}$ and $u_{k-1}$, the next location of the robot $x_k$ can be computed.
\begin{IEEEeqnarray}{CCCCCCCCC}\label{e:xk function}
	x_k & = & f(x_{k-1}, u_{k-1}) & = & 
	\begin{bmatrix}
		f_x(x_{k-1}, u_{k-1})\\
		f_y(x_{k-1}, u_{k-1})\\
		f_\theta(x_{k-1}, u_{k-1})\\
	\end{bmatrix}
\end{IEEEeqnarray}

In the above derivation of the system model it was assumed that there are no noise sources. In the next section, noise  has been modelled into the system.

\subsection{System model with noise}\label{s:20-system-and-measurement-model--system-model-with-noise}
\indent\indent
First, noise was added to the relative displacement with the assumption, that it can be modelled by a random noise vector $q_k$ such that, the noise is a Gaussian distribution with zero mean $\hat{q_k}$ and covariance matrix $U_k$.

\begin{equation} \label{e: Noise Model}
	q_k \sim   N(\hat{q_k} , U_k)
\end{equation}

where

\begin{IEEEeqnarray*}{CCCCCCCCC} \label{e:qk mean}
	\hat{q_k} & = & 
	\begin{bmatrix}
		0\\
		0\\
	\end{bmatrix}
\end{IEEEeqnarray*}

and 

\begin{equation*} \label{e: Uk}
	U_k = \mathrm{E}(q_k - \hat{q_k}) (q_k - \hat{q_k})^T  
\end{equation*}

\begin{IEEEeqnarray*}{CCCCCCCCC} \label{e:Uk covariance}
	U_k & = &  
	\begin{bmatrix}
		{\sigma}^2_{q[\Delta S], k} & {\sigma}_{q[\Delta\theta], k} {\sigma}_{q[\Delta S], k} \\
		{\sigma}_{q[\Delta\theta], k} {\sigma}_{q[\Delta S], k} & {\sigma}^2_{q[\Delta\theta], k} \\
	\end{bmatrix}
\end{IEEEeqnarray*}

With the assumption that the noise sources are independent, the off-diagonal elements of the covariance matrix $U_k$ are equal to zero.
%The computation of variances $ {\sigma}^2_{q[\Delta S], k}  $ and ${\sigma}^2_{q[\theta], k} $ for the model is discussed in section.

The control input, or relative displacement, can be expressed as shown in \eref{e: Uk + noise}.

\begin{equation} \label{e: Uk + noise}
	u_k = j(d_k) + q_k
\end{equation}

\begin{IEEEeqnarray*}{CCCCCCCCC} \label{e:Uk + noise2}
	u_k & = & 
	\begin{bmatrix}
		u_{[\Delta S], k} \\
		u_{[\Delta \theta], k} \\
	\end{bmatrix}
	& + &
	\begin{bmatrix}
		q_{[\Delta S], k} \\
		q_{[\Delta \theta], k} \\
	\end{bmatrix}	
\end{IEEEeqnarray*} 

This makes $u_k$ a random vector. Assuming, that $u_{[\Delta S], k}$ and $u_{[\theta], k}$ are deterministic, uncertainty in $ u_k $ equals the uncertainty in the noise term $q_k$.

The system noise can similarly be modelled by a random noise vector $w_k$ such that, the noise is a Gaussian distribution with zero mean $\hat{w_k}$ and covariance matrix $Q_k$.
This noise source is not directly related to the relative displacement, however it is inherent to the system. Modelling errors, odometry errors, discretization and approximations involved in the derivation of the model all play a part in this noise source. Noise vector $w_k$ is represented in equation \eref{e: Noise Model w_k}.

\begin{equation} \label{e: Noise Model w_k}
	w_k \sim   N(\hat{w_k} , Q_k) 
\end{equation}

where %TODO The problem of continuing statements like that, where you switch between equations and words is, that you should end the sentence with a period. This looks often out of place after the last equation, which is the reason I suggest using tables for legends and explanations. It's cleaner and faster to read. Leave it as is though.

\begin{IEEEeqnarray*}{CCCCCCCCC} \label{e:wk mean}
	\hat{w_k} & = & 
	\begin{bmatrix}
		0\\
		0\\
		0\\
	\end{bmatrix}
\end{IEEEeqnarray*} 

and 

\begin{equation*} \label{e: Qk}
	Q_k = \mathrm{E}(w_k - \hat{w_k}) (w_k - \hat{w_k})^T  
\end{equation*}


\begin{IEEEeqnarray*}{CCCCCCCCC} \label{e:Qk covariance}
	Q_k & = & 
	\begin{bmatrix}
		{\sigma}^2_{w[x], k} & {\sigma}_{w[y], k} {\sigma}_{w[x], k} &  {\sigma}_{w[\theta], k} {\sigma}_{w[x], k} \\
		{\sigma}_{w[x], k} {\sigma}_{w[y], k} & {\sigma}^2_{w[y], k} & {\sigma}_{w[\theta], k} {\sigma}_{w[y], k} \\
%		{\sigma}_{w[x], k} {\sigma}_{w[\theta], k} & {\sigma}_{w[\theta], k} {\sigma}_{w[x], k} & {\sigma}^2_{w[\theta], k} \\
		{\sigma}_{w[x], k} {\sigma}_{w[\theta], k} & {\sigma}_{w[y], k} {\sigma}_{w[\theta], k} & {\sigma}^2_{w[\theta], k} \\ %TODO I think this should be correct, please doublecheck
	\end{bmatrix}
\end{IEEEeqnarray*}

With the assumption that the noise sources are independent, the off-diagonal elements of the covariance matrix $Q_k$ are presumably zero. Determination of matrix $Q_k$ is discussed in section \nameref{s:30-kalman-filter--implementation} \vpageref{s:30-kalman-filter--implementation}.
%The computation of variances $ {\sigma}^2_{w[x], k}  $ , $ {\sigma}^2_{w[y], k}  $ and ${\sigma}^2_{w[\theta], k} $ for the model is discussed in section.

The system can be expressed as shown \vpageref[below]{e: xk + wk}. %TODO Latex might actually push it elsewhere, so I used vref

\begin{equation} \label{e: xk + wk}
	x_k = f(x_{k-1}, u_{k-1}) + w_k
\end{equation}

\begin{IEEEeqnarray}{CCCCCCCCC} \label{e:xk + noise function}
	x_k & = & 
	\begin{bmatrix}
		f_x(x_{k-1}, u_{k-1})\\
		f_y(x_{k-1}, u_{k-1})\\
		f_\theta(x_{k-1}, u_{k-1})\\
	\end{bmatrix}
	& + & 
	\begin{bmatrix}
		w_{[x], k-1} \\
		w_{[y], k-1} \\
		w_{[\theta], k-1} \\
	\end{bmatrix}
\end{IEEEeqnarray}

%$w_k$ consists of noise sources that are not directly related to $u_k$. already discussed
$x_k$ is a random vector and with every time step the variance of system noise increases. Therefore the variance of the location grows with every time step also. %assuming that $f_x$, $f_y$ and $f_\theta$ are deterministic, 

The proposed system model was prepared for the implementation of Kalman filter, which requires as next step the preparation of the measurement model.

\subsection{Measurement model with noise}\label{s:20-system-and-measurement-model--measurement-model-with-noise}
\indent\indent
Starting with the assumption that there is no noise in the measurement, measurement vector $z_k$ simply consists of the corresponding state variables %TODO Could not have been expressed in a more complicated way
and is defined by equation \eref{e:zk}.

\begin{IEEEeqnarray}{CCCCCCCCC} \label{e:zk}
	z_k & = & 
	\begin{bmatrix}
		z_{[x], k} \\
		z_{[y], k} \\
		z_{[\theta], k} \\
	\end{bmatrix}
\end{IEEEeqnarray}

In the proposed system, motion capture system available in the laboratory is used to localize Rollo. It acts as absolute sensor by providing directly the position in $x$ and $y$ coordinates and orientation $\theta$ of the robot. Thus, $z_k$ in this case is simply expressed as \eref{e:zk 2}.

\begin{IEEEeqnarray}{CCCCCCCCC} \label{e:zk 2}
	z_k & = & 
	\begin{bmatrix}
		x_{[x], k} \\
		x_{[y], k} \\
		x_{[\theta], k} \\
	\end{bmatrix}
\end{IEEEeqnarray}

Provided that the motion capture system is not noise free, this has been incorporated into the measurement model. With the assumption, that measurement noise can be modelled by a random noise vector $v_k$ such that, the noise is a Gaussian distribution with zero mean $\hat{v_k}$ and covariance matrix $R_k$. %TODO Made a reference to given motion capture system

\begin{equation}\label{e: Noise Model vk}
	v_k \sim N(\hat{v_k}, R_k)
\end{equation}

where

\begin{IEEEeqnarray*}{CCCCCCCCC} \label{e:vk mean}
	\hat{v_k} & = & 
	\begin{bmatrix}
		0\\
		0\\
		0\\
	\end{bmatrix}
\end{IEEEeqnarray*} 

and 

\begin{equation*} \label{e: Rk}
	R_k = \mathrm{E}(v_k - \hat{v_k}) (v_k - \hat{v_k})^T  
\end{equation*}

%
\begin{IEEEeqnarray*}{CCCCCCCCC} \label{e:Rk covariance}
	R_k & = & 
	\begin{bmatrix}
		{\sigma}^2_{v[x], k} & {\sigma}_{v[y], k} {\sigma}_{v[x], k} &  {\sigma}_{v[\theta], k} {\sigma}_{v[x], k} \\
		{\sigma}_{v[x], k} {\sigma}_{v[y], k} & {\sigma}^2_{v[y], k} & {\sigma}_{v[\theta], k} {\sigma}_{v[y], k} \\
%		{\sigma}_{v[x], k} {\sigma}_{v[\theta], k} & {\sigma}_{v[\theta], k} {\sigma}_{v[x], k} & {\sigma}^2_{v[\theta], k} \\
		{\sigma}_{v[x], k} {\sigma}_{v[\theta], k} & {\sigma}_{v[y], k} {\sigma}_{v[\theta], k} & {\sigma}^2_{v[\theta], k} \\ %TODO Same as with Q, please double check
	\end{bmatrix}
\end{IEEEeqnarray*}

Again, assuming that the noise sources are independent, the off-diagonal elements of the covariance matrix $R_k$ are presumably zero.

The final measurement model can be expressed as shown in \eref{e:zk + noise2}.
\begin{equation} \label{e: zk + noise} %TODO Shouldn't this be expressed in a analog way to x_k as g(x_k-1, u_k-1) + v_k? Just a formatting and consistency issue
z_k = x_k + v_k
\end{equation}

\begin{IEEEeqnarray}{CCCCCCCCC}\label{e:zk + noise2}
	z_k & = & 
	\begin{bmatrix}
		x_{[x], k} \\
		x_{[y], k} \\
		x_{[\theta], k} \\
	\end{bmatrix}
	& + & 
	\begin{bmatrix}
		v_{[x], k-1} \\
		v_{[y], k-1} \\
		v_{[\theta], k-1} \\
	\end{bmatrix}
\end{IEEEeqnarray}

%Since the measurement noise $v_k$ is a Gaussian vector, this makes $z_k$ a random vector.
Since the measurement noise $v_k$ is a Gaussian random vector, this makes $z_k$ a random vector. %TODO I think you mean Gaussian random vector, but that name might be problematic: http://www.math.utah.edu/~davar/math6010/2011/GaussianRandomVectors.pdf

%TODO CHECKED


\clearpage
\section{Kalman filter}\label{s:30-kalman-filter}
\indent\indent
Kalman filter is an algorithm that uses a series of measurements observed over time, containing statistical noise and other inaccuracies, and produces estimates of unknown variables that tend to be more precise than those based on a single measurement alone\footnote{e-Study Guide for: Introduction to Probability Theory and Stochastic Processes}. %Cram101 Textbook Reviews - e-Study Guide for: Introduction to Probability Theory and Stochastic Processes
%TODO Okay, so this should be either bibliography, which I don't like doing right now or a footnote maybe. If it should be a link, where should it point to?
%Provide an actual link, and not only to the wikipage, to the actual source
%It is from a book but i cant find which. wiki doesnt tell
%https://books.google.it/books?id=uRwkAgAAQBAJ&pg=PT274&lpg=PT274&dq=series+of+measurements+observed+over+time,+containing+statistical+noise+and+other+inaccuracies,+and+produces+estimates+of+unknown+variables+that+tend+to+be+more+precise+than+those+based+on+a+single+measurement+alone&source=bl&ots=xHmg3SPxnk&sig=JjRBDfNfG6IlBbWWBZT68JKXh_g&hl=en&sa=X&ved=0ahUKEwiL_qaSs6DLAhVEtg8KHYUICa0Q6AEIIjAB#v=onepage&q=series%20of%20measurements%20observed%20over%20time%2C%20containing%20statistical%20noise%20and%20other%20inaccuracies%2C%20and%20produces%20estimates%20of%20unknown%20variables%20that%20tend%20to%20be%20more%20precise%20than%20those%20based%20on%20a%20single%20measurement%20alone&f=false
%TODO

A physical system is driven by a set of external inputs or controls. Its outputs are evaluated by sensors such that, the knowledge on the system's behaviour is solely given by the inputs and the observed outputs. For example, in case of Rollo, the physical system is a mobile robot and given is the problem of localizing it. The control, or the input, is defined by the velocity command given to the left and right wheels, which determines the relative displacement of Rollo. The observed output is the position and orientation of Rollo measured from the motion capture system. The observations convey the errors and uncertainties in the process, namely the sensor noise and the system errors. Based on the available information (control inputs and observations), Kalman filter computes an estimate of the system's state by minimizing the variance of the estimation error. From a theoretical standpoint, the main assumptions of the Kalman filter are that the underlying system is a linear dynamical system and that all error terms and measurements have a Gaussian distribution. %TODO Not sure about "such that," anymore.

Kalman filtering is a recursive analytical technique involving two main steps: prediction and innovation.

Prediction is also known as \emph{time update} and refers to prediction of state variables using information from previous state and control input. This step does not involve using measurement.

Innovation which is also known as \emph{correction} or \emph{measurement update} refers to estimation of state variable using measurement.

Kalman filter is broadly used in robotics for solving the localization problem, because of its efficiency and accuracy. Some of its characteristics are:

\begin{enumerate}
	\item Very easy implementation
	\item Computationally efficient, updates filter when providing new measurements to the existing data set
	\item Uncertainty estimates are provided as part of the filter
	\item Recursive algorithm, which makes it suitable for real time applications using only the present input measurements and the previously calculated state.
\end{enumerate}

All members of Kalman family of filters like extended Kalman filter and unscented Kalman filter, comply with a structured sequence of six steps per iteration:

\begin{enumerate}
%TODO Don't use textbf here. It's better to define a command for this: \emphb{}
	\item \textbf{State estimate time update:} An updated state prediction $\hat{x}_{k|k-1}$ is made, based on a priori information and the system model.
	\item \textbf{Error covariance time update:} The second step is to determine the predicted state-estimate error covariance matrix $\Sigma_{k|k-1}$ based on a priori information and the system model.
	\item \textbf{Estimate system output:} The third step is to estimate the system's output $\hat{z}_{k}$ corresponding to the timestamp of the most recently received measurement using present a priori information.
	\item \textbf{Estimator gain matrix:} The fourth step is to compute the estimator gain matrix $H_k$.
	\item \textbf{State estimate measurement update:} The fifth step is to compute the a posteriori state estimate $\hat{x}_{k|k}$ by updating the a priori estimate using the estimator gain and the output prediction error.
	\item \textbf{Error covariance measurement update:} The final step computes the a posteriori error covariance matrix $\Sigma_{k|k}$.
\end{enumerate}

\subsection{Kalman filter equations for linear system}\label{s:30-kalman-filter--equations-linear-system}
\indent\indent
In order to implement Kalman filter first represent the linear system as follows.

\begin{align} %TODO Why do you use align here?
	x_{k+1} & = A_{k}x_{k} + B_{k}u_{k} + w_{k} \notag \\
	z_{k} & = C_{k}x_{k} + v_{k} %TODO We should at least mention that the direct transmission matrix D is omitted
	\label{e:system} %TODO We agreed on e:label notation
\end{align}

%where $w_{k} \sim N\left(0, Q_k\right)$ and $v_{k} \sim N\left(0,R_k\right)$.
where $w_{k} \sim N\left(0, Q_k\right)$ and $v_{k} \sim N\left(0,R_k\right)$ as described in  \nameref{s:20-system-and-measurement-model--system-model-with-noise} \vpageref{s:20-system-and-measurement-model--system-model-with-noise} and \nameref{s:20-system-and-measurement-model--measurement-model-with-noise} \vpageref{s:20-system-and-measurement-model--measurement-model-with-noise} respectively. %TODO doublecheck order

%, and $x_{0} \sim N\left(x_{0|-1},P_{0|-1}\right)$.

For Kalman filter $A$, $B$, $C$, $Q$ and $R$ can be time variant. However, for simplicity it is assumed that they are time invariant for the provided system.
Given initial state estimate $\hat{x}_{0|0}$ and initial state covariance matrix $\Sigma_{0|0}$ the Kalman filter can be computed using following set of equations.

%\subsubsection{Prediction or Time update:}\label{s:30-kalman-filter--equations-linear-system--prediction}
\subsubsection{Prediction (time update)}\label{s:30-kalman-filter--equations-linear-system--prediction}
%\indent\indent
\begin{align} %TODO To align equations IEEEarray should be used, that would also take care of the number being centered, but leave it as is
	\hat{x}_{k|k-1} & =  A\hat{x}_{k-1|k-1} + Bu_{k-1} \notag \\
	\Sigma_{k|k-1} & = A \Sigma_{k-1|k-1} A^T + Q
	\label{e:predictionLinear}
\end{align}

%\subsubsection{Innovation or measurement update}\label{s:30-kalman-filter--equations-linear-system--innovation}
\subsubsection{Innovation (measurement update)}\label{s:30-kalman-filter--equations-linear-system--innovation}
%\indent\indent
\begin{align}
	H_k & =  \Sigma_{k|k-1} C^T {(C \Sigma_{k|k-1} C^T + R)}^{-1}\notag \\
	\hat{x}_{k|k} & =  \hat{x}_{k|k-1} + H_k [z_{k} - C\hat{x}_{k|k-1}]\notag \\
	\Sigma_{k|k} & = [I - H_k C]\Sigma_{k|k-1}
	\label{e:innovationLinear}
\end{align}

% Note that $x \sim
% N\left(\mu,\Sigma\right)$ means
%\begin{equation}
%P\left(x\right) = \frac{1}{\left(2\pi\right){|\Sigma|}^{1/2}} e^{-\frac{1}{2}\left(x-\mu\right)\trans\Sigma^{-1}\left(x-\mu\right)}.\notag
%\end{equation}
%We also have: $Ex = \mu$ and $E\left(x-\mu\right)\left(x-\mu\right)\trans = \Sigma$.
%
%
%We will use the following notation:
%\begin{align}
%\hat{x}_{t|t} & = E\left[x_{t}|y_{0\colon t}\right]\notag \\
%P_{t|t} & = E\left[\left(x_{t} - \hat{x}_{t|t}\right)\left(x_{t} - \hat{x}_{t|t}\right)\trans|y_{0\colon t}\right]\notag \\
%\hat{x}_{t+1|t} & = E\left[x_{t+1}|y_{0\colon t}\right]\notag \\
%P_{t+1|t} & = E\left[\left(x_{t+1} - \hat{x}_{t+1|t}\right)\left(x_{t+1} - \hat{x}_{t+1|t}\right)\trans|y_{0\colon t}\right]\notag
%\end{align}
%
%%Note that because $x_{t|\cdot}$ is a Gaussian random variable, it is
%sufficient to only keep track of the mean and covariance.  We can do
%so by the following computations at each time $t$:
%\begin{align}
%\hat{x}_{t+1|t} & = A\hat{x}_{t|t} + Bu_{t}\notag \\
%P_{t+1|t} & = AP_{t|t}A\trans +\Sigma_{w}\notag \\
%\hat{x}_{t+1|t+1} & = \hat{x}_{t+1|t} + K_{t+1}\left(y_{t+1}-C\hat{x}_{t+1|t}\right)\notag \\
%K_{t+1} & = P_{t+1|t}C\trans\left(CP_{t+1|t}C\trans + \Sigma_{v}\right)^{-1}\notag \\
%P_{t+1|t+1} & = P_{t+1|t} - P_{t+1|t}C\trans\left(CP_{t+1|t}C\trans + \Sigma_{v}\right)^{-1}CP_{t+1|t}
%\end{align}


\subsection{Kalman filter equations for non-linear system}\label{s:30-kalman-filter--equations-non-linear-system}
\indent\indent
Now we consider a non-linear extension to the Kalman filter, \emph{Extended Kalman Filter (EKF)}. The EKF implements Kalman filter for non-linear system dynamics that result from the linearization of the original non-linear filter dynamics around the previous state estimates. %TODO Do not use bold or any other font style to make a point. Manual search and change of occurences is a PIA

A non linear system can be represented as follows.

\begin{align}
	x_{k} & = f\left( x_{k-1}, u_{k-1} \right) + w_{k-1} \notag \\
	z_{k} & = h\left( x_{k} \right) + v_{k-1}
	\label{e:nonlinearsystem}
\end{align}

where $w_{k} \sim N\left(0, Q_k\right)$ and  $v_{k} \sim N\left(0, R_k\right)$.

Another assumption is that $f(\cdot)$, $h(\cdot)$, $Q$ and $R$ are time invariant for the provided non-linear system. $f(\cdot)$ and $h(\cdot)$ are linearized about the prior best estimate of the states at each instant of time by finite difference method in order to compute covariances.
Given initial state estimate $\hat{x}_{0|0}$ and initial state covariance matrix $\Sigma_{0|0}$ the extended Kalman filter can be computed using following set of equations.

%\subsubsection{Prediction or time update}\label{s:30-kalman-filter--equations-non-linear-system--prediction}
\subsubsection{Prediction (time update)}\label{s:30-kalman-filter--equations-non-linear-system--prediction}
%\indent\indent
\begin{align}
	\hat{x}_{k|k-1} & =  f\left( \hat{x}_{k-1|k-1}, u_{k-1} \right) \notag \\
	\Sigma_{k|k-1} & = J_f \Sigma_{k-1|k-1} J_f^T + Q
	\label{e:predictionnonLinear}
\end{align}

\subsubsection{Innovation (measurement update)}\label{s:30-kalman-filter--equations-non-linear-system--innovation}
%\indent\indent
\begin{align}
	H_k & =  \Sigma_{k|k-1} J_h^T {(J_h \Sigma_{k|k-1} J_h^T + R)}^{-1} \notag \\
	\hat{x}_{k|k} & =  \hat{x}_{k|k-1} + H_k [z_{k} - h\left( \hat{x}_{k|k-1} \right)] \notag \\
	\Sigma_{k|k} & = [I - H_kJ_h] \Sigma_{k|k-1}
	\label{e:innovationnonLinear}
\end{align}

where $J_f$ and $J_h$ are the jacobian matrices.

$J_f$ is the jacobian matrix containing the partial derivative of the system function $f(\cdot)$ with respect to the state $x$, evaluated at the last state estimate $\hat{x}_{k-1|k-1}$ and control input $u_{k-1}$. %TODO doublecheck f(\cdot), because if bots dots correspond to state and input, then the previous use should be also checked

$J_h$ is the jacobian matrix containing partial derivatives of the measurement function $h(\cdot)$ with respect to the state $x$, evaluated at the prior state estimate $\hat{x}_{k|k-1}$.

\subsection{Extended Kalman filter equations for odometry}\label{s:30-kalman-filter--equations-odometry}
\indent\indent
After deriving physical model of the provided system for \nameref{s:10-odometry} and understanding the extended Kalman filter in \nameref{s:30-kalman-filter--equations-non-linear-system}, preparation for the EKF equations for odometry can be done.

\begin{IEEEeqnarray}{CCCCCCCCC}\label{e:KFxk + noise function} %TODO Optimally there would be references to all previous partial steps how these equations were derived, but this alone is very good without.
	\begin{bmatrix}
		x_{[x], k} \\
		x_{[y], k} \\
		x_{[\theta], k} \\
	\end{bmatrix}
 & = & 
	\begin{bmatrix}
		f_x(x_{k-1}, u_{k-1})\\
		f_y(x_{k-1}, u_{k-1})\\
		f_\theta(x_{k-1}, u_{k-1})\\
	\end{bmatrix}
	& + & 
	\begin{bmatrix}
		w_{[x], k-1})\\
		w_{[y], k-1})\\
		w_{[\theta], k-1})\\
	\end{bmatrix}
\end{IEEEeqnarray} 

\begin{IEEEeqnarray}{CCCCCCCCC}\label{e:KFSysEq}
	\begin{bmatrix}
		x_{[x], k} \\
		x_{[y], k} \\
		x_{[\theta], k} \\
	\end{bmatrix}
	& = & 
	\begin{bmatrix}
		x_{[x], k-1} + u_{[\Delta] S, k-1} \cdot \cos(x_{[\Theta], k-1} - \frac{u_{[\Delta \Theta], k-1}}{2}) \\
		x_{[y], k-1} + u_{[\Delta] S, k-1} \cdot \sin(x_{[\Theta], k-1} - \frac{u_{[\Delta \Theta], k-1}}{2}) \\
		x_{[\theta], k-1} - u_{[\Delta \Theta], k-1})\\
	\end{bmatrix}
	& + & 
	\begin{bmatrix}
		w_{[x], k-1})\\
		w_{[y], k-1})\\
		w_{[\theta], k-1})\\
	\end{bmatrix}
\end{IEEEeqnarray}

%\subsubsection{Prediction or Time update:}\label{s:30-kalman-filter--equations-odometry}
\subsubsection{Prediction (time update)}\label{s:30-kalman-filter--equations-odometry--prediction}
%\indent\indent

\begin{IEEEeqnarray}{CCCCC}\label{e:KFprediction1Odometry}
	\begin{bmatrix}
		\hat{x}_{[x], k|k-1} \\
		\hat{x}_{[y], k|k-1} \\
		\hat{x}_{[\theta], k|k-1} \\
	\end{bmatrix}
	& = & 
	\begin{bmatrix}
		\hat{x}_{[x], k-1|k-1} + u_{[\Delta] S, k-1} \cdot \cos(\hat{x}_{[\Theta], k-1|k-1} - \frac{u_{[\Delta \Theta], k-1}}{2}) \\
		\hat{x}_{[y], k-1} + u_{[\Delta] S, k-1} \cdot \sin(\hat{x}_{[\Theta], k-1|k-1} - \frac{u_{[\Delta \Theta], k-1}}{2}) \\
		\hat{x}_{[\theta], k-1|k-1} - u_{[\Delta \Theta], k-1})\\
	\end{bmatrix}
\end{IEEEeqnarray}

\begin{align}
	J_{f, k} & =  \frac{\partial f(x)}{\partial x}\Bigr|_{x = \hat{x}_{k-1|k-1}, u = u_{k-1}} \notag \\
	& = 
	\begin{bmatrix}
		\frac{\partial f_x}{\partial x_{[x]}} & \frac{\partial f_x}{\partial x_{[y]}} & \frac{\partial f_x}{\partial x_{[\theta]}} \\
		\frac{\partial f_y}{\partial x_{[x]}} & \frac{\partial f_y}{\partial x_{[y]}} & \frac{\partial f_y}{\partial x_{[\theta]}} \\
		\frac{\partial f_\theta}{\partial x_{[x]}} & \frac{\partial f_\theta}{\partial x_{[y]}} & \frac{\partial f_\theta}{\partial x_{[\theta]}} \\
	\end{bmatrix}_{x = \hat{x}_{k-1|k-1}, u = u_{k-1}} \notag \\
	& = 
	\begin{bmatrix}
		1 & 0 & - u_{[\Delta] S} \cdot \sin(x_{[\Theta]} - \frac{u_{[\Delta \Theta]}}{2})\\
		0 & 1 & + u_{[\Delta] S} \cdot \cos(x_{[\Theta]} - \frac{u_{[\Delta \Theta]}}{2}) \\
		0 & 0 & 1\\
	\end{bmatrix}_{x = \hat{x}_{k-1|k-1}, u = u_{k-1}} \notag \\
	\label{e:JacobfOdometry}
\end{align}

\begin{align}
	%\hat{x}_{k|k-1} & =  f\left(\hat{x}_{k-1|k-1},u_{k-1}\right) \notag \\
	\Sigma_{[x], k|k-1} & = J_f \Sigma_{[x], k-1|k-1} J_f^T + Q 
	\label{e:predictionOdometry}
\end{align}

%where $\Sigma_{[x]}$ is a 3x3 state covariance matrix and $Q$ is a 3x3 process covariance matrix.

%
%\begin{IEEEeqnarray}{CCCCC} \label{e:KFprediction2Odometry}
%	\begin{bmatrix}
%		\Sigma_{[x][x], k|k-1} & \Sigma_{[x][y], k|k-1} & \Sigma_{[x][\theta], k|k-1} \\
%		\Sigma_{[y][x], k|k-1} & \Sigma_{[y][y], k|k-1} & \Sigma_{[y][\theta], k|k-1} \\
%		\Sigma_{[\theta][x], k|k-1} & \Sigma_{[\theta][x], k|k-1} & \Sigma_{[\theta][\theta], k|k-1} \\
%	\end{bmatrix}
%	& = & 
%	\begin{bmatrix}
%		1 & 0 & - u_{[\Delta] S} \cdot \sin(x_{[\Theta]} - \frac{u_{[\Delta \Theta]}}{2})\\
%		0 & 1 & + u_{[\Delta] S} \cdot \cos(x_{[\Theta]} - \frac{u_{[\Delta \Theta]}}{2}) \\
%		0 & 0 & 1\\
%	\end{bmatrix}_{x = \hat{x}_{k-1|k-1}, u = u_{k-1}} \notag \\
%	\begin{bmatrix}
%			\Sigma_{[x][x], k|k-1} & \Sigma_{[x][y], k|k-1} & \Sigma_{[x][\theta], k|k-1} \\
%			\Sigma_{[y][x], k|k-1} & \Sigma_{[y][y], k|k-1} & \Sigma_{[y][\theta], k|k-1} \\
%			\Sigma_{[\theta][x], k|k-1} & \Sigma_{[\theta][x], k|k-1} & \Sigma_{[\theta][\theta], k|k-1} \\
%	\end{bmatrix}
%		\begin{bmatrix}
%			1 & 0 & - u_{[\Delta] S} \cdot \sin(x_{[\Theta]} - \frac{u_{[\Delta \Theta]}}{2})\\
%			0 & 1 & + u_{[\Delta] S} \cdot \cos(x_{[\Theta]} - \frac{u_{[\Delta \Theta]}}{2}) \\
%			0 & 0 & 1\\
%		\end{bmatrix}^T_{x = \hat{x}_{k-1|k-1}, u = u_{k-1}} \notag \\
%%	J_f \Sigma_{[x], k-1|k-1} J_f^T 
%	& + &
%	\begin{bmatrix}
%			{\sigma}^2_{w[x], k} & 0 &  0\\
%			0 & {\sigma}^2_{w[y], k} & 0\\
%			0 & 0 & {\sigma}^2_{w[\theta], k} \\
%	\end{bmatrix} 
%\end{IEEEeqnarray} 

%\subsubsection{Innovation or Measurement update:}\label{s:30-kalman-filter--equations-odometry--innovation}
\subsubsection{Innovation (measurement update)}\label{s:30-kalman-filter--equations-odometry--innovation}
%\indent\indent

\begin{align}
	J_{h, k}  & =  \frac{\partial h(x)}{\partial x}\Bigr|_{x = \hat{x}_{k|k-1}} \notag \\
	& =  	\begin{bmatrix}
		\frac{\partial h_x}{\partial x_{[x]}} & \frac{\partial h_x}{\partial x_{[y]}} & \frac{\partial h_x}{\partial x_{[\theta]}} \\
		\frac{\partial h_y}{\partial x_{[x]}} & \frac{\partial h_y}{\partial x_{[y]}} & \frac{\partial h_y}{\partial x_{[\theta]}} \\
		\frac{\partial h_\theta}{\partial x_{[x]}} & \frac{\partial h_\theta}{\partial x_{[y]}} & \frac{\partial h_\theta}{\partial x_{[\theta]}} \\
	\end{bmatrix}_{x = \hat{x}_{k|k-1}, u = u_{k-1}} \notag \\
	& =  	\begin{bmatrix}
		1 & 0 & 0 \\
		0 & 1 & 0 \\
		0 & 0 & 1\\
	\end{bmatrix}_{x = \hat{x}_{k|k-1}, u = u_{k-1}} \notag \\
	\label{e:JacobhOdometry}
\end{align}

Using the above derived jacobian matrix \eref{e:JacobhOdometry} for computation of Kalman gain matrix $H_k$, a posteriori state estimate and a posteriori error covariance matrix following concludes.

\begin{align}
	H_k & =  \Sigma_{k|k-1}  {( \Sigma_{k|k-1} + R)}^{-1}\notag \\
	\hat{x}_{k|k} & =  \hat{x}_{k|k-1} + H_k [z_{k} - \hat{x}_{k|k-1}]\notag \\
	\Sigma_{k|k} & = [I - H_kJ_h]\Sigma_{k|k-1}
	\label{e:innovationnonLinearmodel}
\end{align}


\subsection{Practical implementation of extended Kalman filter}\label{s:30-kalman-filter--implementation}
\indent\indent
Proceeding with the EKF model for odometry, initialization of the model is necessary before practical implementation, which requires following components to be initialized:

\begin{enumerate}
	\item Initial state estimate $\hat{x}_{0|0}$,
	\item Initial state covariance matrix $\Sigma_{0|0}$,
	\item Process covariance matrix $Q$,
	\item Measurement covariance matrix $R$.
\end{enumerate}

\subsubsection{Initial state estimate $\hat{x}_{0|0}$}\label{s:30-kalman-filter--implementation--initial-state-estimate} %TODO Never use special signs or whitespaces in labels, can cleanup at the end, don't worry now
\indent\indent
This is the initial estimate of the state vector required for the first iteration of the EKF. In the provided system, Optitrack Motion Capture system is used for measurement. Optitrack provides ground truth and positional accuracy of up to sub-millimeter range. For performed tests the measurement sensor readings were used to determine  $\hat{x}_{0|0}$.

\subsubsection{Initial state covariance matrix $\Sigma_{0|0}$}\label{s:30-kalman-filter--implementation--initial-state-covariance}
\indent\indent
Initial state covariance matrix is based on the initialization error of the state. If the initial state estimate is very close to the actual state, this matrix will contain very small values. With the assumption that noise sources for different state elements are independent, the off diagonal elements of the covariance matrix can be assumed to equal zero.

Usually if this matrix is unknown identity matrix is used, since state covariance matrix is updated in every iteration of EKF. For a stable EKF this matrix should be converging over time. An initial estimate closer to the actual state will offer faster convergence of the Kalman filter. %TODO "better" exchanged

Since the initial state is determined from the motion capture system, initial state covariance matrix could be assumed to be zero. However, since the chosen procedure simulates a sensor not as accurate as motion capture, the initial state covariance matrix is taken as identity.

\subsubsection{Process covariance matrix Q}\label{s:30-kalman-filter--implementation--process-covariance-q}
\indent\indent
This is the error covariance matrix of the process and gives an estimate of uncertainty in the state equations. The uncertainty in the process could be a result of various sources of error, including modeling errors, odometry errors, discretization and approximations involved in the derivation of the model.

In order to get a better understanding of error in the model, computation of error based on odometry model from log files and analysis were performed.
% but without any further detailed insights.
%In order to get a feel of error in the model, we computed error based on odometry model from log files.
%TODO and could understand not much about it -- Genius!

For testing a different range of values for $Q$ was chosen in order to understand the behaviour of the EKF better. %TODO in the provided system?

\subsubsection{Measurement covariance matrix R}\label{s:30-kalman-filter--equations-odometry--measuremenet-covariance-r}
\indent\indent
This is the error covariance matrix of measurement sensor and provides a measure of how uncertain the measurement is. As discussed earlier, Optitrack Motion Capture system is used for measurement and it provides ground truth. For the case when the measurement is very accurate, matrix $R$ will carry very small variances and can be approximated to zero. However, in order to simulate EKF for a system, whose measurement sensor is not as accurate, different range of values for the measurement covariance matrix $R$ was used.

%TODO CHECKED

\subsection{Divergence of state covariance matrix $\Sigma_{k|k}$}\label{s:30-kalman-filter--divergence-of-state-covariance-matrix}
\indent\indent
Proceeding with initialization of EKF as discussed above, it was observed that the filter behaved well for a specific period of time after initialization. However, after a certain amount of time the state covariance matrix started diverging very fast, resulting in failure of the filter.

It was understood that a possible reason behind this could be lack of input excitation that results in growing values of state covariance matrix and large spread of eigenvalues. In order to solve this issue, different techniques can be used to stabilize estimation and prevent windup of state estimation and covariance matrix.

The issue has been solved by performing \link[Cholesky decompostion]{https://en.wikipedia.org/wiki/Cholesky_decomposition} in the computation of Kalman gain matrix. Cholesky factorization is a decomposition of a Hermitian, a positive-definite matrix, into the product of a lower triangular matrix, or alternatively an upper triangular matrix, and its conjugate transpose. Cholesky decomposition offers numerical stability to the system, which is the main reason it was chosen.

Implementation was based on the assumption that the state covariance matrix $\Sigma_{k|k}$ is symmetrical. This resulted in acceptable behaviour of the filter, however, it slowed down the performance of EKF. With Cholesky decomposition, the innovation update of EKF can be written as shown in \eref{e:choleskynonLinear}

\begin{align}
	U & = CholsekyDecomposition (J_h \Sigma_{k|k-1} J_h^T + R)\notag \\ %TODO Suggest to use an operator for Cholesky decomposition defined before, but leave it as is
	\hat{x}_{k|k} & =  \hat{x}_{k|k-1} +  [\Sigma_{k|k-1} {U}^{-1}]{U^T}^{-1} [z_{k} - h\left(\hat{x}_{k|k-1}\right)]\notag \\
	\Sigma_{k|k} & = \Sigma_{k|k-1} - [\Sigma_{k|k-1} {U}^{-1}][\Sigma_{k|k-1} {U}^{-1}]^T
	\label{e:choleskynonLinear}
\end{align}

where $CholsekyDecomposition (X)$ produces an upper triangular matrix $U$ from the diagonal and upper triangle of matrix $X$, thus satisfying the equation $U^TU=X$.

%TODO CHECKED


\clearpage
\section{Robot Operating System (ROS)}\label{s:40-ros} %TODO Could you take a quick look?
\indent\indent
\link[Robot Operating System (ROS)]{http://wiki.ros.org/} is a collection of software frameworks for robot software development, it works as middleware for work with complex robotic problems. ROS uses the publisher-subscriber software architecture model for communication between nodes. The presented problem of localization of a humanoid robot using extended Kalman filter, which has been described in detail in \nameref{s:30-kalman-filter}, has been solved using ROS.
Five nodes have been developed respecting the aspects of modularity and interchangeability of software:

\begin{itemize}
	\item Preprocessor node
	\item Control node
	\item Communication node
	\item Extended Kalman filter node
	\item Visualization node
%	\item [Analysis node] :(
\end{itemize}

Each node is supposed to fulfil one specific function, so that the software can be used for different tasks and in different environments. However there are several aspects that have been merged into same nodes, that might be contra-intuitive. Functionalities of the nodes are distributed the following way:

\begin{itemize}
	\item Preprocessor node:
	\begin{enumerate}
		\item Filter the raw data from motion capture system
		\item Publish filtered data along with timestamp for modelling of odometry and the measurement in Kalman filter
	\end{enumerate}
	\item Control node:
	\begin{enumerate}
		\item Translate input from keyboard into linear and angular velocities within unitary limits ($-100\% \div 100\%$)
		\item Publish data as Twist message for further processing
	\end{enumerate}
	\item Communication node:
	\begin{enumerate}
		\renewcommand{\theenumi}{\Alph{enumi}}
		\item Normal operation mode
		\begin{enumerate}
			\item Translate data from control node into a three byte message for Rollo
			\item Publish decoded velocities
			\item Send commands continuously at a given rate to Rollo
			\item Perform emergency procedure if connection to control node is lost
		\end{enumerate}
		\item Square test of n-th order based on the UMBmark test procedure describer in detail in \nameref{s:10-odometry--measuring-odometry-errors}
		\begin{enumerate}
			\item Perform a cycle of forward movement and turns to move the robot along a square
			\item For higher than first order square test turn around between runs
		\end{enumerate}
	\end{enumerate}
	\item Extented Kalman filter node:
	\begin{enumerate}
		\item Initialize EKF
		\item Preprocessing of acquired data to make comparison of relevant information
		\item Estimate of state using EKF
		\item Odometry data calculation
		\item Publish results
	\end{enumerate}
	\item Visualization node:
	\begin{enumerate}
		\item Visualize data holding position and orientation of robot, from preprocessor and extended Kalman filter, which provides estimates of state and odometry data
	\end{enumerate}
\end{itemize}

Nodes have been written in C++ programming language with the exception of visualization node, which has been written in Python, mainly because of easy access to the powerful \link[Matplotlib library]{http://matplotlib.org/}. There has been also a significant amount of testing and prototyping of software done in Matlab and Python, mainly for the odometry model and extended Kalman filter implementation as well as analysis. Additional scripts in Bash shell were also written, mostly for the purpose of easier repetition of tasks. All of the significant files can be found in the \link[GitHub repository established for this project]{https://github.com/em-er-es/rollo}.

The basic software architecture model implemented is publish-subscribe given the architecture ROS uses represented by \fref{40-ros--nodes-diagram} shows the correlation between individual nodes and environment.

\includesvg[0.75]{Graphics/40-ros--nodes-diagram-color}{Basic structure of developed ROS nodes.\label{f:40-ros--nodes-diagram}}

%\includesvg[0.75]{Graphics/40-ros--nodes-diagram}{Basic structure of developed ROS nodes.\label{f:40-ros--nodes-diagram}}

The \link[Optitrack Motion Capture]{http://www.optitrack.com/} system and \link[ROS \emph{mocap\_optitrack}]{http://wiki.ros.org/mocap_optitrack} node are represented as one entity, that receives data through infrared cameras from objects using highly light reflective markers. Rollo recognized by the system, after user input as a rigid body, provides that way it's position and orientation data through the \emph{mocap\_optitrack} node. This data gets filtered through the preprocessor node in accordance with user provided parameters, that publishes it with a timestamp. The user provides input in form of keyboard input that the control node interprets and conveys as a standard geometry \emph{Twist} message to the communication node. This node, depending on the operation mode, continuously sends UDP packets to Rollo through provided setup of a wireless router and publishes velocity commands it decoded from the control node to EKF node. The optimal frequency rate for the communication node has been established by trial and error at $10 \ Hz$, where the response to used input is fast enough to stop Rollo without delay. Kalman filter node uses data from preprocessor and communication node to perform localization of Rollo and publishes estimates of the state. Filtered motion capture data from the preprocessor node and estimates from EKF node as well as the odometry model data act as inputs for the visualization node. This node provides visual feedback of the whole system to the user as shown in figure \fref{50-simulation-and-testing--visualization-node}.

Because of the different function each node performs, not every node is necessary to be run, which is clearly visible in the ROS package launcher file \verb|rollo.launch|. It is possible to control rollo only using the control and communication nodes. If connection to the control is lost, depending on user set parameters, the communication node performs the emergency procedure and stays in that mode. This critical aspect has been marked on the graph \fref{40-ros--nodes-diagram} and is described later in detail. Also the square test can be performed by the communication node alone. The EKF node includes the odometry model. With data provided by the communication node as input EKF node publishes the position and orientation based on the physical odometry model.

A few aspects have been addressed while developing the software. One of those aspects is safety of operation. Should the control node loose connection to the master and at the same time be sending commands other than full stop, where linear and angular velocities are equal to zero, then in normal case the communication node would continue sending data with last values received from control node and the robot would be uncontrollable. This is the reason a safety, or emergency, procedure has been implemented. After a period of time, which can be specified from the command line using the \verb|em| parameter, a full stop command is being send for ten times. Should the control node reestablish connection, the communication node will continue to work in normal procedure.

Since the robot has been tested in laboratory conditions, the algorithm implemented is sufficient for given condition. However it is not very robust and could be further improved. For example, the stop command could be send continuously, until control node is reconnected with ROS master or the communication node forcefully exited. Another improvement would be to send a special message that this event occurred, so that the user is informed about it without delay.

Next feature implemented into the communication node is the square test. This particular test has been implemented in accordance to UMBmark test procedure described in \nameref{s:10-odometry--measuring-odometry-errors}. The implemented algorithm lets the user specify the forward and turning times for the square test, which is necessary in case of not having access to direct odometry data in form of encoder readings. The square test can be performed in multiple runs, so that each cycle includes eight steps of interchanging forward movement and turning.

Should there be multiple runs specified, the robot would turn around after each cycle, which is to rotate $180\degree$ and continue with step 1. In other case that would be the last or only run. Ideally the robot would stop at exactly the same position it started with the initial orientation. Since there are systematic and random errors, this is only achievable for a given tolerance. However in case of Rollo, the errors and mechanical structure differences are so great, that the test is basically not practical. During tests runs it has been only confirmed, what the analysis of the logs performed for the extended Kalman filter node concluded, namely that the turning times differ significantly, which is most probably due to mechanical asymmetry.

The square test algorithm has been implemented directly into the communication node, because of easy access to all necessary functions and no conflicts with other nodes. However logically it should either have it's own node or be implemented into the control node. However then aspects of priority and safety aspects arise.

Since the encoder feedback from Rollo was unavailable, the communication node did not include necessary code for receiving that data and processing it. Great effort has been undertaken to prepare Rollo from the hardware side for encoder feedback, but in the end the low-level software was missing. This bidirectional communication between Rollo and communication node has been portrayed in diagram \fref{40-ros--nodes-diagram}, since it is a crucial feature for proper implementation of any localization solver.

Further details on the setup and nodes are described in next section \nameref{s:50-simulation-and-testing}. More in depth documentation of the actual code and algorithms has been done using Doxygen in two formats: \link[HTML version]{http://htmlpreview.github.io/?http://github.com/em-er-es/rollo/blob/master/Documentation/html/index.html} and \link[local LaTeX document form]{https://github.com/em-er-es/rollo/raw/master/Documentation/latex/refman.pdf}.

%TODO CHECKED


\clearpage
\section{Mechanical and electrical improvements}\label{s:45-mechanical-and-electrical-improvements}
\indent\indent
At the initial stage of the project it became apparent that several changes and improvements needed to be introduced to Rollo in order to complete the assignment. Rollo was developed to simulate human walking motion. The legs consisted of springs, making the whole structure very flexible as shown in figure \fref{45-mechanical-and-electrical-improvements--initial-state-mechanical}. Also the electrical components were connected in a suboptimal way as portrayed by image in figure \fref{45-mechanical-and-electrical-improvements--initial-state-electrical}.

\scalefigcrop{Graphics/45-mechanical-and-electrical-improvements--initial-state-mechanical.png}{0.5}{Rollo at initial state of project.\label{f:45-mechanical-and-electrical-improvements--initial-state-mechanical}}{100}{50}{200}{0}

\scalefigcrop{Graphics/45-mechanical-and-electrical-improvements--initial-state-electrical.png}{0.75}{Wires and connectors of Rollo.\label{f:45-mechanical-and-electrical-improvements--initial-state-electrical}}{100}{300}{200}{300}

This setup introduced additional errors in the movement and furthermore also localization of Rollo, which is the reason additional wooden structure was implemented to make the robot more rigid and the movements more predictable. The whole process is documented in figures \fref{45-mechanical-and-electrical-improvements--mechanical-improvements-01} $\div$ \fref{45-mechanical-and-electrical-improvements--mechanical-improvements-03} for the mechanical part and figures \fref{45-mechanical-and-electrical-improvements--electrical-improvements-01} $\div$ \fref{45-mechanical-and-electrical-improvements--electrical-improvements-07} for the electrical part.

\scalefigcrop{Graphics/45-mechanical-and-electrical-improvements--mechanical-improvements-01.png}{0.5}{Wooden stabilization pieces after cutting and drilling holes used to make the Rollo more rigid.\label{f:45-mechanical-and-electrical-improvements--mechanical-improvements-01}}{100}{140}{260}{200}

\scalefigcrop{Graphics/45-mechanical-and-electrical-improvements--mechanical-improvements-02.png}{0.5}{Rollo disassembled.\label{f:45-mechanical-and-electrical-improvements--mechanical-improvements-02}}{0}{0}{200}{0}

\scalefigcrop{Graphics/45-mechanical-and-electrical-improvements--mechanical-improvements-03.png}{0.5}{Lower legs of Rollo.\label{f:45-mechanical-and-electrical-improvements--mechanical-improvements-03}}{0}{200}{0}{100}

\clearpage

\scalefigcrop{Graphics/45-mechanical-and-electrical-improvements--electrical-improvements-01.png}{0.5}{Preparation of power connectors for the microcontroller boards with help of thermoshrink.\label{f:45-mechanical-and-electrical-improvements--electrical-improvements-01}}{0}{0}{0}{0}

\scalefigcrop{Graphics/45-mechanical-and-electrical-improvements--electrical-improvements-02.png}{0.5}{Power connector in final state.\label{f:45-mechanical-and-electrical-improvements--electrical-improvements-02}}{0}{0}{0}{0}

\clearpage

\scalefigcrop{Graphics/45-mechanical-and-electrical-improvements--electrical-improvements-03.png}{0.4}{Voltage regulator with new power cables. The cable tie was used to secure the damaged power connector case, which was of very poor quality.\label{f:45-mechanical-and-electrical-improvements--electrical-improvements-03}}{0}{0}{0}{0}

\scalefigcrop{Graphics/45-mechanical-and-electrical-improvements--electrical-improvements-04.png}{0.4}{Control cable for the motor controller with a connector table for easy access.\label{f:45-mechanical-and-electrical-improvements--electrical-improvements-04}}{0}{0}{0}{0}

\clearpage

\scalefigcrop{Graphics/45-mechanical-and-electrical-improvements--electrical-improvements-05.png}{0.5}{Motor controller using proper control signal connectors with high quality isolation and new power cables.\label{f:45-mechanical-and-electrical-improvements--electrical-improvements-05}}{0}{0}{0}{0}

\scalefigcrop{Graphics/45-mechanical-and-electrical-improvements--electrical-improvements-06.png}{0.5}{Power and control signal cables secured using cable ties. The encoders were connected using professional soldering technique and isolated properly.\label{f:45-mechanical-and-electrical-improvements--electrical-improvements-06}}{0}{0}{0}{0}


\clearpage

At one point during the work with Rollo one of the power connectors caused a short circuit, which damaged the \link[DROK voltage regulator]{http://www.droking.com/drok-great-handy-volt-buck-converter-with-voltmeter-creates-easy-convenient-voltage-regulation/}'s \link[semiconductor integrated circuit LM2596]{http://www.ti.com/lit/ds/symlink/lm2596.pdf} seen in figure \fref{45-mechanical-and-electrical-improvements--electrical-improvements-03}. After this incident the decision was made to replace all power connections with new power cables with higher and only one diameter. Also all control signal cables have been replaced and secured with cleaned up cable ties as seen through figures \fref{45-mechanical-and-electrical-improvements--electrical-improvements-01} $\div$ \fref{45-mechanical-and-electrical-improvements--electrical-improvements-07}. Only the VGA socket cable connecting both microcontroller boards has not been replaced, however it's connections have also been improved.

\scalefigcrop{Graphics/45-mechanical-and-electrical-improvements--electrical-improvements-07.png}{0.5}{Encoder and motor controller connections to the microcontroller board using IDE40 cables.\label{f:45-mechanical-and-electrical-improvements--electrical-improvements-07}}{0}{0}{0}{0}

\clearpage

\scalefigcrop{Graphics/45-mechanical-and-electrical-improvements--final-state.png}{0.5}{Final state of Rollo after improvements. Additional hardware in form of Kinect andd RaspberryPi have been added for another project. \label{f:45-mechanical-and-electrical-improvements--final-state}}{0}{0}{0}{0}

The final state after mechanical and electrical improvements can be seen in image in figure \fref{45-mechanical-and-electrical-improvements--final-state}. The introduced improvements provided a safe and disturbance-free operation not only for this project. Also the capability of reading the encoders has been enabled through a complete rewiring and clean-up of signal cables.


\clearpage
\section{Simulation and testing}\label{s:50-simulation-and-testing}
\subsection{Simulation of extended Kalman filter}\label{s:50-simulation-and-testing--simulation-of-ekf}
\indent\indent
EKF algorithm was first simulated in Matlab using recorded data from Rollo's test runs.
Measurement logs were collected for the robot's straight line test runs and initial value of measurement was set as the initial state estimate. EKF update was performed using this initial state estimate, control input for the given log and measurement for the log.

Figure \fref{20-matlab-ekf-1} shows the results of EKF based on one of a log file. \verb|x state[1]| and \verb|x state[2]| represent position of robot in $x$ and $y$ coordinates in meters respectively. \verb|x state[3]| represents orientation $\Theta$ of the robot in radians. The blue lines show the state estimates updates with EKF, while the red lines represent the measurement, which is the actual state.

It can be observed from the plots that the EKF based state estimates are influenced by measurement and are able to converge to the varying values of measurement.

%\includesvg[0.75]{Graphics/Results/ekfresult1}{Odometry model with the simplified 4 wheel configuration for the right turn.\label{f:10-odometry-rt-4w}}

\scalefigcrop{Graphics/Results/ekfresult1.pdf}{0.75}{Results of EKF simulation based on a log file.\label{f:20-matlab-ekf-1}}{20}{200}{0}{200} %TODO Write EKF out in the captions. What log file

\scalefigcrop{Graphics/Results/ekfstability.pdf}{0.75}{Results of EKF simulation based on a log file for longer iterations to verify stability.\label{f:20-matlab-ekf-stability}}{20}{200}{0}{200}

Figure \fref{20-matlab-ekf-stability} shows the results of EKF update for longer iterations to verify the stability of EKF. If original EKF equations are directly used with the system, the state estimate and state covariance matrix starts to diverge after sometime, as discussed in section \nameref{s:30-kalman-filter--divergence-of-state-covariance-matrix}. This figure shows result of performing Cholesky decomposition for measurement update. %TODO Not sure where to refer here


\subsection{Testing of extended Kalman filter}\label{s:50-simulation-and-testing--testing-of-ekf}
\subsubsection{Test setup}\label{s:50-simulation-and-testing--testing-of-ekf--test-setup}
\indent\indent
In order to conduct the tests both battery packs were fully charged and five infrared markers were placed on Rollo at different points, creating an asymmetrical structure, so that it could be reliably tracked by the motion capture system.

The motion capture system itself, was calibrated so that the $x$-axis and $y$-axis for localization were defined according to Cartesian coordinate system. The Robot was placed in the test area with its orientation aligned to $x$-axis, ergo pointing eastwards from the operational station position, and then defined as a rigid body in the motion capture system. This ensured that the orientation of the robot was $0$ radians when it was aligned to $x$-axis similar to the developed odometry model.

The complete software package that received localization from the motion capture system, controlled Rollo, processed data to implement EKF and visualization was developed within the ROS framework as described in \nameref{s:40-ros}.
Rollo was manually controlled using the keyboard and communication with Rollo was done at 10Hz. The preprocessor node, responsible for gathering and processing of measurement data, was updated $25 \ Hz$. Hence, the EKF update was also performed approximately at a rate of $25 \ Hz$. Testing sessions during development showed, that the EKF node could be easily run at a frequency rate of $10 \ Hz$ and still produce reasonable results, which when visualized where barerly

Unfortunately, the encoder feedback was unavailable for the test, however the communication node was reprogrammed to send certain angular velocities for the wheels at a given command. The complete range of velocities was not covered, only the command values shown in the table \tref{command-velocities-estimates} were tested. This is due to anticipation of more precise results using lower half of velocity range, which resulted in reprogramming of Rollo low-level software itself to accommodate this request.

In the start of each test run, the robot position and orientation read from the motion capture system was used as the initial state estimate. Initial state covariance matrix was set as identity matrix.

State prediction using the odometry based model alone was also studied for comparison with EKF based model. However, in the absence of encoder data this model was very crude. Moreover, the testing floor was uneven and had visible irregularities, which introduced non systematic errors that are not modelled in the odometry.

Initial state for the odometry model was taken as the same state for the EKF based model. The logs were collected sometime after the test was conducted and analyzed. This was due to lag in the system. %Detail? No
However, the videos of online visualization for the tests were recorded from the very start of the run. There were several technical difficulties including problems with networking that obstructed optimal testing conditions. Rollo on multiple occasions lost signal to the provided wireless router and continued running with last received command. This has also been a factor behind the decision to implement emergency procedure into the communication node, even though this problem persists, because of the provided hardware and low-level software of Rollo.

There were also problems with Optitrack Motion Capture system that had difficulties providing clear images of the scene at reasonable frame rates of $90 \ fps$ relative to system's maximum of $120 \ fps$, using the grayscale reference video mode.

\subsubsection{Testing variables}\label{s:50-simulation-and-testing--testing-of-ekf--testing-variables}
\indent\indent
Rollo was tested with different process covariance matrix $Q$ and measurement covariance matrix $R$ values to analyse EKF performance. The two matrices and their properties are described in detail in
\nameref{s:20-system-and-measurement-model}, \nameref{s:20-system-and-measurement-model--measurement-model-with-noise} and \nameref{s:30-kalman-filter--divergence-of-state-covariance-matrix}.

For process noise covariance matrix, it was assumed that the noise sources were independent for the three states, position in $x$ and $y$ coordinates and the orientation $\Theta$, and the noise variances for all three states were assumed to be equal and constant. Assigning the standard deviation for all states as $q$, the $Q$ matrix can be written as shown in \eref{e:Qk covariance test}.

\begin{IEEEeqnarray}{CCC} \label{e:Qk covariance test}
	Q_k & = & 
	\begin{bmatrix}
		{q}^2 & 0 &  0\\
		0 & {q}^2 & 0\\
		0 & 0 & {q}^2\\
	\end{bmatrix}
\end{IEEEeqnarray}

Similarly for measurement noise covariance matrix the same assumption has been made. Assigning the standard deviation for the all states as $r$, the $R$ matrix can be written as shown in \eref{e:Rk covariance test}.

\begin{IEEEeqnarray}{CCC} \label{e:Rk covariance test}
	R_k & = &  
	\begin{bmatrix}
		{r}^2 & 0 &  0\\
		0 & {r}^2 & 0\\
		0 & 0 & {r}^2\\
	\end{bmatrix}
\end{IEEEeqnarray}

\begin{table}[h]
	\centering
	\caption{Predetermined wheels angular velocity based on test logs for given forward command.}
	\label{t:02qandr}
	\begin{tabularx}{0.4\textwidth}{@{}|Y|Y|@{}}
		\hline
		\textbf{$q$} & \textbf{$r$} \\ \hline
		\hline
		0.1 & 0.1 \\ \hline
		0.1 & 1.0 \\ \hline
		0.1 & 10.0 \\ \hline
		1.0 & 10.0 \\ \hline
		10.0 & 10.0 \\ \hline
		100.0 & 10.0 \\ \hline
		8.0 & 32.0 \\ \hline
	\end{tabularx}
\end{table}

Table \tref{02qandr} enlists the combinations of $q$ and $r$ that were tested. The EKF update rate was at $10 \ Hz$ for those particular test runs. For every test the initial state estimate was reassigned and the EKF node was restarted, so that the odometry model could be reinitialized to the same position as EKF estimate.


%TODO NEED TO QUANTIFY ANALYSIS!!!
%TODO CHECKED

\subsubsection{Test results and analysis}\label{s:50-simulation-and-testing--testing-of-ekf--test-results-and-analysis}
\indent\indent
During online testing the localization was studied using the visualization node. A snapshot of the real time visualization is shown in figure \fref{50-simulation-and-testing--visualization-node}.

\scalefigcrop{Graphics/50-simulation-and-testing--visualization-node.png}{0.75}{Real time visualization: localization of the robot based on EKF, odometry alone and the measurement.\label{f:50-simulation-and-testing--visualization-node}}{0}{0}{0}{38}

Logs were generated for offline and in-depth analysis of the system. ROS provides the capability to rerun the tests from recorded logs and evaluate the performance of nodes again based on the same data. Several Bash scripts have been written specifically for the purpose of easier repetition of recording and replaying of acquired log data as described in the \link[GitHub repository files list]{https://github.com/em-er-es/rollo/raw/master/FILES.txt}.

For every test run two different plots were generated. One showed position of the robot computed according to odometry, EKF and motion capture system and the second plot displayed position and orientation of the robot with respect to time. Chosen plots of the conducted test runs are shown and described in this section.

\scalefigcrop{Graphics/Results/01F19-EKF-q0-1-r0-1.pdf}{0.75}{Test 1, velocity command 19\% for both left and right wheels, $q = 0.1$, $r = 0.1$.\label{f:30-Test-1a}}{20}{190}{0}{209}

\scalefigcrop{Graphics/Results/01F19-EKF-q0-1-r0-1wrttime.pdf}{0.75}{Test 1, velocity command 19\% for both left and right wheels, $q = 0.1$, $r = 0.1$. Figure shows all three states with respect to time.\label{f:32-Test-1b}}{20}{190}{0}{210}

%\phantomsection\label{s:50-simulation-and-testing--testing-of-ekf--test-results-and-analysis--test-1}
\hypertarget{s:50-simulation-and-testing--testing-of-ekf--test-results-and-analysis--test-1}{}
Initial tests were conducted for $q = 0.1$ and $r = 0.1$. Figures \fref{30-Test-1a} and \fref{32-Test-1b} show a straight line run for 19\% velocity command. It can be observed from the plot that the state estimate is almost superimposed on measurement line at each computation point. This proves that the implemented EKF is capable of very accurate state estimation. Odometry even though intuitively showing completely incorrect results by drifting far from actual position of the robot with time, shows the same character of Rollo's movement. Since this was only crudely modelled without encoders feedback, no efforts were made to improve it. The reason for symmetrically opposite movement was an error in communication node, where velocities estimates for left and right wheels were switched. Also here the EKF node was not restarted properly, resulting in odometry model having a different initial position and orientation.

The initial values of $q$ and $r$ involved in EKF yielded respectable performance. Further tests were performed by adding more noise to the measurement model using a larger $r$.

\scalefigcrop{Graphics/Results/02F12-EKF-q0-1-r1-0.pdf}{0.75}{Test 2, velocity command 12\% for both left and right wheels, $q = 0.1$, $r = 1.0$.\label{f:34-Test-2a}}{20}{190}{0}{210}

\scalefigcrop{Graphics/Results/02F12-EKF-q0-1-r1-0wrttime.pdf}{0.75}{Test 2, velocity command 12\% for both left and right wheels, $q = 0.1$, $r = 1.0$. Figure shows all three states with respect to time.\label{f:36-Test-2b}}{20}{190}{0}{210}

By taking $q = 0.1$ and $r = 1.0$, the tracking ability of EKF was reduced. Figures \fref{34-Test-2a} and \fref{36-Test-2b} show a straight line run for 12\% velocity command. It can be observed that the state estimate was close to the measurement line, but was unable to reach it and remained at a varying offset to the measurement.

\scalefigcrop{Graphics/Results/04fL12R19-EKF-q0-1-r10.pdf}{0.75}{Test 3, velocity command 12\% for left wheel and 19\% for right wheel, $q = 0.1$, $r = 10$.\label{f:38-Test-3a}}{20}{190}{0}{210}

\scalefigcrop{Graphics/Results/04fL12R19-EKF-q0-1-r10wrttime.pdf}{0.75}{Test 3, velocity command 12\% for left wheel and 19\% for right wheel, $q = 0.1$, $r = 10$. Figure shows all three states with respect to time.\label{f:40-Test-3b}}{20}{190}{0}{210}

Further noise was added to the measurement model by setting $q = 0.1$ and keeping $r = 10.0$. Figures \fref{38-Test-3a} and \fref{40-Test-3b} show plots of a counter clockwise rotation for 12\% left velocity command and 19\% right velocity command. State estimate visibly drifted from the actual position. Therefore, with the increase in measurement noise, the weight of measurement data is lower in the Kalman filter. Further tests were conducted with $r$ kept constant at value 10. Also worth noting are the slips of Rollo's wheels visible by jumps in the measurement data. As already mentioned, the laboratory ground was uneven and irregular introducing random errors, especially during rotations of Rollo.

\scalefigcrop{Graphics/Results/05fL19R12-EKF-q-1-0-r10.pdf}{0.75}{Test 4, velocity command 19\% for left wheel and 12\% for right wheel, $q = 1.0$, $r = 10$.\label{f:42-Test-4a}}{20}{190}{0}{210}

\scalefigcrop{Graphics/Results/05fL19R12-EKF-q-1-0-r10wrttime.pdf}{0.75}{Test 4, velocity command 19\% for left wheel and 12\% for right wheel, $q = 1.0$, $r = 10$. Figure shows all three states with respect to time.\label{f:44-Test-4b}}{20}{190}{0}{210}

Figures \fref{42-Test-4a} and \fref{44-Test-4b} show another counter clockwise rotation at 12\% left velocity command and 19\% right velocity command for $q = 1.0$ and $r = 10.0$. In this scenario the EKF response has widely improved. By increasing the value of $q$ the uncertainty in process model was also increased. In comparison to previous test, the measurement had more significance. However, an error between the EKF based state estimate and the measurement can still be seen. %TODO We should have added an area fill between measurement and EKF to make this really clear, like I did in my Runge-Kutta work

\scalefigcrop{Graphics/Results/06fL12R19-EKF-q10-r10.pdf}{0.75}{Test 5, velocity command 12\% for left wheel and 19\% for right wheel, $q = 10$, $r = 10$.\label{f:46-Test-5a}}{20}{190}{0}{210}

\scalefigcrop{Graphics/Results/06fL12R19-EKF-q10-r10wrttime.pdf}{0.75}{Test 5, velocity command 12\% for left wheel and 19\% for right wheel, $q = 10$, $r = 10$. Figure shows all three states with respect to time.\label{f:48-Test-5b}}{20}{190}{0}{210}

Further noise was added to the process model by increasing $q$ to the value $10$. Figures \fref{46-Test-5a} and \fref{48-Test-5b} portray a counter clockwise rotation at 12\% left velocity command and 19\% right velocity command for  $q = 10.0$ and $r = 10.0$. It can be observed that the EKF was again able to track the localisation of the robot very well. The performance is comparable to results seen in \hyperlink{s:50-simulation-and-testing--testing-of-ekf--test-results-and-analysis--test-1}{test 1}, when the values for $q$ and $r$ were equal at value $0.1$. Thus, it can be understood that the relative ratio between $Q$ and $R$ matrices determines the performance of EKF, not the absolute values of $Q$ and $R$ alone.

\scalefigcrop{Graphics/Results/07fL19R12-EKF-q100-r10.pdf}{0.75}{Test 6, velocity command 19\% for left wheel and 12\% for right wheel, $q = 100$, $r = 10$.\label{f:50-Test-6a}}{20}{190}{0}{210}

\scalefigcrop{Graphics/Results/07fL19R12-EKF-q100-r10wrttime.pdf}{0.75}{Test 6, velocity command 19\% for left wheel and 12\% for right wheel, $q = 100$, $r = 10$. Figure shows all three states with respect to time.\label{f:52--Test-6b}}{20}{190}{0}{210}

In figures \fref{50-Test-6a} and \fref{52--Test-6b} a clockwise rotation at 19\% left velocity command and 12\% right velocity command for $q = 100.0$ and $r = 10.0$ was plotted. Again, by increasing the value of $q$ more noise was added to the process model and therefore the measurement gained more influence on the estimates in the Kalman filter model. It can be clearly observed that EKF is easily able to localize the robot very accurately. Measurement sensors  from the motion capture system provide, after a proper calibration, very accurate readings of Rollo's localization.

\scalefigcrop{Graphics/Results/08fL12R19-EKF-q8-r32.pdf}{0.75}{Test 7, velocity command 12\% for left wheel and 19\% for right wheel, $q = 8$, $r = 32$.\label{f:54--Test-7a}}{20}{190}{0}{210}

\scalefigcrop{Graphics/Results/08fL12R19-EKF-q8-r32wrttime.pdf}{0.75}{Test 8, velocity command 12\% for left wheel and 19\% for right wheel, $q = 8$, $r = 32$. Figure shows all three states with respect to time.\label{f:56--Test-7b}}{20}{190}{0}{210}

Final test was performed with values $q = 8.0$ and $r = 32.0$. Figures \fref{54--Test-7a} and \fref{56--Test-7b} show plots of a counter clockwise rotation at 12\% left velocity command and 19\% right velocity command. Since $r$ was greater than $q$, the measurement model has had a lower impact on the Kalman filter as compared to the process model. It can be observed from the plots that the EKF was unable to localize the robot accurately and state estimate has visibly drifted from the actual position of Rollo, especially during the curve.


\clearpage
\section{Conclusions}\label{s:100-conclusions}
\indent\indent
Localization in technology is the estimation of position and state of a system in the world frame of reference by making use of limited information. Localization has been one of the primary challenges in robotics in the field of mobile robots. It is very common in mobile robots to use odometry and inertial measurement unit (IMU) as relative position sensors and GPS as absolute position sensor to estimate state of the robot. Extended Kalman filter is a widely used filtering technique in estimating the localization of a robot that processes feedback from two or more sensors. 

The presented project starts with preparing the odometry based physical model of Rollo, showing it's advantages and disadvantages with respect to the localization problem.
Furthermore errors associated with odometry, divided into systematic and non systematic, were presented along with the UMBmark based square test technique to determine dominant odometry errors. 

Next the preparation of the system and measurement models was conducted and the equations for the implementation of Kalman filter and then extended Kalman filter were defined. EKF was first simulated and verified in Matlab. The final tests were conducted on Rollo and the performance of extended Kalman filter was analysed by varying process covariance matrix $Q$ and measurement covariance matrix $R$. Given appropriate ratio between the covariances the implemented EKF performs satisfactory and solves the problem of localization of Rollo.

Additional improvements like the square test and Cholesky decomposition have been implemented into the developed software, along with various other aspects, like a standalone odometry model written in Python. Also mechanical and electrical improvements have been performed on Rollo as described in section \nameref{s:45-mechanical-and-electrical-improvements}.

For future work, it is proposed to first implement encoders feedback in the system and validate the EKF with working odometry. This would also require expanding current ROS nodes, especially the communication node. Even though the encoders feedback is currently unavailable in Rollo, the modelling of the system and software was designed for a swift and easy transition to odometry feedback. Furthermore, another sensor should be introduced in the system, since the motion capture system will most probably be unavailable in real life applications. 

In regards to the mechanical system of the robot, it is recommended that a different material for the wheels should be used to improve traction and reduce skidding of the robot. The wheels of the robot also need to be properly aligned so that the odometry errors are reduced.


% % % % CODE REFERENCE



% % % % CODE REFERENCE


%\end{Section}
\end{Problem}
%\layout
\end{spacing}
\end{document}


% % % Licence

%----------------------------------------------------------------------%
% The following is copyright and licensing information for
% redistribution of this LaTeX source code; it also includes a liability
% statement. If this source code is not being redistributed to others,
% it may be omitted. It has no effect on the function of the above code.
%----------------------------------------------------------------------%
% Copyright (c) 2007, 2008, 2009, 2010, 2011 by Theodore P. Pavlic
%
% Unless otherwise expressly stated, this work is licensed under the
% Creative Commons Attribution-Noncommercial 3.0 United States License. To
% view a copy of this license, visit
% http://creativecommons.org/licenses/by-nc/3.0/us/ or send a letter to
% Creative Commons, 171 Second Street, Suite 300, San Francisco,
% California, 94105, USA.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
% OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
% IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
% CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
% TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
% SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
%----------------------------------------------------------------------%
