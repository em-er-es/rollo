\hypertarget{classudp__client__server_1_1udp__server}{}\section{udp\+\_\+client\+\_\+server\+:\+:udp\+\_\+server Class Reference}
\label{classudp__client__server_1_1udp__server}\index{udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classudp__client__server_1_1udp__server_ae44891f41370ca856da0fe50923a1b25}{udp\+\_\+server} (const std\+::string \&addr, int \hyperlink{rollo__comm_8cpp_a63c89c04d1feae07ca35558055155ffb}{port})
\begin{DoxyCompactList}\small\item\em Initialize a U\+D\+P server object. \end{DoxyCompactList}\item 
\hyperlink{classudp__client__server_1_1udp__server_acdce04ccdcc420d4f959110c75ec9b1c}{$\sim$udp\+\_\+server} ()
\begin{DoxyCompactList}\small\item\em Clean up the U\+D\+P server. \end{DoxyCompactList}\item 
int \hyperlink{classudp__client__server_1_1udp__server_ace51743964b568c021b0f3154f4c0306}{get\+\_\+socket} () const 
\begin{DoxyCompactList}\small\item\em The socket used by this U\+D\+P server. \end{DoxyCompactList}\item 
int \hyperlink{classudp__client__server_1_1udp__server_a78b6867c5dc04599c8b146fe4971459a}{get\+\_\+port} () const 
\begin{DoxyCompactList}\small\item\em The port used by this U\+D\+P server. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classudp__client__server_1_1udp__server_a9b82191caf4ccc1d6822d5f92e382e02}{get\+\_\+addr} () const 
\begin{DoxyCompactList}\small\item\em Return the address of this U\+D\+P server. \end{DoxyCompactList}\item 
int \hyperlink{classudp__client__server_1_1udp__server_aa103886a58d575868dc01ad0d3f73cbc}{recv} (char $\ast$msg, size\+\_\+t max\+\_\+size)
\begin{DoxyCompactList}\small\item\em Wait on a message. \end{DoxyCompactList}\item 
int \hyperlink{classudp__client__server_1_1udp__server_af376121a83f6c07187f077bc77aa6e27}{timed\+\_\+recv} (char $\ast$msg, size\+\_\+t max\+\_\+size, int max\+\_\+wait\+\_\+ms)
\begin{DoxyCompactList}\small\item\em Wait for data to come in. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classudp__client__server_1_1udp__server_ae44891f41370ca856da0fe50923a1b25}{}\index{udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}!udp\+\_\+server@{udp\+\_\+server}}
\index{udp\+\_\+server@{udp\+\_\+server}!udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}}
\subsubsection[{udp\+\_\+server(const std\+::string \&addr, int port)}]{\setlength{\rightskip}{0pt plus 5cm}udp\+\_\+client\+\_\+server\+::udp\+\_\+server\+::udp\+\_\+server (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{addr, }
\item[{int}]{port}
\end{DoxyParamCaption}
)}\label{classudp__client__server_1_1udp__server_ae44891f41370ca856da0fe50923a1b25}


Initialize a U\+D\+P server object. 

This function initializes a U\+D\+P server object making it ready to receive messages.

The server address and port are specified in the constructor so if you need to receive messages from several different addresses and/or port, you\textquotesingle{}ll have to create a server for each.

The address is a string and it can represent an I\+Pv4 or I\+Pv6 address.

Note that this function calls connect() to connect the socket to the specified address. To accept data on different U\+D\+P addresses and ports, multiple U\+D\+P servers must be created.

\begin{DoxyNote}{Note}
The socket is open in this process. If you fork() or exec() then the socket will be closed by the operating system.
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
We only make use of the first address found by getaddrinfo(). All the other addresses are ignored.
\end{DoxyWarning}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classudp__client__server_1_1udp__client__server__runtime__error}{udp\+\_\+client\+\_\+server\+\_\+runtime\+\_\+error}} & The \hyperlink{classudp__client__server_1_1udp__client__server__runtime__error}{udp\+\_\+client\+\_\+server\+\_\+runtime\+\_\+error} exception is raised when the address and port combinaison cannot be resolved or if the socket cannot be opened.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em addr} & The address we receive on. \\
\hline
\mbox{\tt in}  & {\em port} & The port we receive from. \\
\hline
\end{DoxyParams}
\hypertarget{classudp__client__server_1_1udp__server_acdce04ccdcc420d4f959110c75ec9b1c}{}\index{udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}!````~udp\+\_\+server@{$\sim$udp\+\_\+server}}
\index{````~udp\+\_\+server@{$\sim$udp\+\_\+server}!udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}}
\subsubsection[{$\sim$udp\+\_\+server()}]{\setlength{\rightskip}{0pt plus 5cm}udp\+\_\+client\+\_\+server\+::udp\+\_\+server\+::$\sim$udp\+\_\+server (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classudp__client__server_1_1udp__server_acdce04ccdcc420d4f959110c75ec9b1c}


Clean up the U\+D\+P server. 

This function frees the address info structures and close the socket. 

\subsection{Member Function Documentation}
\hypertarget{classudp__client__server_1_1udp__server_a9b82191caf4ccc1d6822d5f92e382e02}{}\index{udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}!get\+\_\+addr@{get\+\_\+addr}}
\index{get\+\_\+addr@{get\+\_\+addr}!udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}}
\subsubsection[{get\+\_\+addr() const }]{\setlength{\rightskip}{0pt plus 5cm}std\+::string udp\+\_\+client\+\_\+server\+::udp\+\_\+server\+::get\+\_\+addr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classudp__client__server_1_1udp__server_a9b82191caf4ccc1d6822d5f92e382e02}


Return the address of this U\+D\+P server. 

This function returns a verbatim copy of the address as passed to the constructor of the U\+D\+P server (i.\+e. it does not return the canonalized version of the address.)

\begin{DoxyReturn}{Returns}
The address as passed to the constructor. 
\end{DoxyReturn}
\hypertarget{classudp__client__server_1_1udp__server_a78b6867c5dc04599c8b146fe4971459a}{}\index{udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}!get\+\_\+port@{get\+\_\+port}}
\index{get\+\_\+port@{get\+\_\+port}!udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}}
\subsubsection[{get\+\_\+port() const }]{\setlength{\rightskip}{0pt plus 5cm}int udp\+\_\+client\+\_\+server\+::udp\+\_\+server\+::get\+\_\+port (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classudp__client__server_1_1udp__server_a78b6867c5dc04599c8b146fe4971459a}


The port used by this U\+D\+P server. 

This function returns the port attached to the U\+D\+P server. It is a copy of the port specified in the constructor.

\begin{DoxyReturn}{Returns}
The port of the U\+D\+P server. 
\end{DoxyReturn}
\hypertarget{classudp__client__server_1_1udp__server_ace51743964b568c021b0f3154f4c0306}{}\index{udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}!get\+\_\+socket@{get\+\_\+socket}}
\index{get\+\_\+socket@{get\+\_\+socket}!udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}}
\subsubsection[{get\+\_\+socket() const }]{\setlength{\rightskip}{0pt plus 5cm}int udp\+\_\+client\+\_\+server\+::udp\+\_\+server\+::get\+\_\+socket (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classudp__client__server_1_1udp__server_ace51743964b568c021b0f3154f4c0306}


The socket used by this U\+D\+P server. 

This function returns the socket identifier. It can be useful if you are doing a select() on many sockets.

\begin{DoxyReturn}{Returns}
The socket of this U\+D\+P server. 
\end{DoxyReturn}
\hypertarget{classudp__client__server_1_1udp__server_aa103886a58d575868dc01ad0d3f73cbc}{}\index{udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}!recv@{recv}}
\index{recv@{recv}!udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}}
\subsubsection[{recv(char $\ast$msg, size\+\_\+t max\+\_\+size)}]{\setlength{\rightskip}{0pt plus 5cm}int udp\+\_\+client\+\_\+server\+::udp\+\_\+server\+::recv (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{msg, }
\item[{size\+\_\+t}]{max\+\_\+size}
\end{DoxyParamCaption}
)}\label{classudp__client__server_1_1udp__server_aa103886a58d575868dc01ad0d3f73cbc}


Wait on a message. 

This function waits until a message is received on this U\+D\+P server. There are no means to return from this function except by receiving a message. Remember that U\+D\+P does not have a connect state so whether another process quits does not change the status of this U\+D\+P server and thus it continues to wait forever.

Note that you may change the type of socket by making it non-\/blocking (use the \hyperlink{classudp__client__server_1_1udp__server_ace51743964b568c021b0f3154f4c0306}{get\+\_\+socket()} to retrieve the socket identifier) in which case this function will not block if no message is available. Instead it returns immediately.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em msg} & The buffer where the message is saved. \\
\hline
\mbox{\tt in}  & {\em max\+\_\+size} & The maximum size the message (i.\+e. size of the {\ttfamily msg} buffer.)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes read or -\/1 if an error occurs. 
\end{DoxyReturn}
\hypertarget{classudp__client__server_1_1udp__server_af376121a83f6c07187f077bc77aa6e27}{}\index{udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}!timed\+\_\+recv@{timed\+\_\+recv}}
\index{timed\+\_\+recv@{timed\+\_\+recv}!udp\+\_\+client\+\_\+server\+::udp\+\_\+server@{udp\+\_\+client\+\_\+server\+::udp\+\_\+server}}
\subsubsection[{timed\+\_\+recv(char $\ast$msg, size\+\_\+t max\+\_\+size, int max\+\_\+wait\+\_\+ms)}]{\setlength{\rightskip}{0pt plus 5cm}int udp\+\_\+client\+\_\+server\+::udp\+\_\+server\+::timed\+\_\+recv (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{msg, }
\item[{size\+\_\+t}]{max\+\_\+size, }
\item[{int}]{max\+\_\+wait\+\_\+ms}
\end{DoxyParamCaption}
)}\label{classudp__client__server_1_1udp__server_af376121a83f6c07187f077bc77aa6e27}


Wait for data to come in. 

This function waits for a given amount of time for data to come in. If no data comes in after max\+\_\+wait\+\_\+ms, the function returns with -\/1 and errno set to E\+A\+G\+A\+I\+N.

The socket is expected to be a blocking socket (the default,) although it is possible to setup the socket as non-\/blocking if necessary for some other reason.

This function blocks for a maximum amount of time as defined by max\+\_\+wait\+\_\+ms. It may return sooner with an error or a message.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em msg} & The buffer where the message will be saved. \\
\hline
\mbox{\tt in}  & {\em max\+\_\+size} & The size of the {\ttfamily msg} buffer in bytes. \\
\hline
\mbox{\tt in}  & {\em max\+\_\+wait\+\_\+ms} & The maximum number of milliseconds to wait for a message.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/1 if an error occurs or the function timed out, the number of bytes received otherwise. 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/emeres/.\+hdd/\+Documents/\+Studia/\+Università degli studi di Genova/\+D\+I\+B\+R\+I\+S/\+Tutti i corsi/86805 -\/ S\+O\+F\+T\+W\+A\+R\+E A\+R\+C\+H\+I\+T\+E\+C\+T\+U\+R\+E\+S F\+O\+R R\+O\+B\+O\+T\+I\+C\+S/\+A\+S01/rollo/src/udp.\+h\item 
/home/emeres/.\+hdd/\+Documents/\+Studia/\+Università degli studi di Genova/\+D\+I\+B\+R\+I\+S/\+Tutti i corsi/86805 -\/ S\+O\+F\+T\+W\+A\+R\+E A\+R\+C\+H\+I\+T\+E\+C\+T\+U\+R\+E\+S F\+O\+R R\+O\+B\+O\+T\+I\+C\+S/\+A\+S01/rollo/src/udp.\+cpp\end{DoxyCompactItemize}
